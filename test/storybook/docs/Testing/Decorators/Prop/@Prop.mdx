import rules from './data/rules.json';
import { Meta } from '@storybook/addon-docs/blocks';
import data from './data/components.json';
import overlay from './data/test-coverage.json';
import React, { useMemo, useState } from 'react';
import RulesAtAGlance from '../_shared/RulesAtAGlance.jsx';

<Meta title="Testing/Decorators/@Prop"/>

# @Prop Decorator

The `@Prop` decorator exposes public properties on components. This page documents the decorator properties, rules, generated components, component grouping, and test cases summary.

## Decorator Properties

- Type: `@Prop` supports common types, including `string`, `number`, `boolean`, `Array`, `Object`, and `Set`.
- reflect: when true, reflects the value to a corresponding attribute.
- mutable: when true, allows internal mutation of the prop.

## Rules (at a glance)
<RulesAtAGlance rules={rules} sourcePath="./data/rules.json" modeLabel="Prop type" />

## Test Cases

Note: Test cases are high‑level scenarios, not a 1‑to‑1 mapping to tests (it() blocks). A single WDIO test can exercise many generated components, and a component can participate in multiple tests. The “Tested By” column in the Generated Components table shows which case(s) (#1, #2) each component is covered by. All @Prop tests reside under <code>test/wdio/prop/tests</code>.

export const PropTestCasesTable = () => {
  const items = overlay.items || [];
  const groupIn = (set) => items.filter(i => set.has(i.group));
  const count = (arr) => ({ tested: arr.filter(i => i.tested).length, total: arr.length });

  const primitiveSet = new Set(['string', 'number', 'boolean']);
  const complexSet = new Set(['Array', 'Object', 'Set']);

  const primitive = count(groupIn(primitiveSet));
  const complex = count(groupIn(complexSet));

  const normalizeBool = (v) => v === true || v === 'true' || v === '✓';
  const primitiveReflectTrueArr = items.filter(i => primitiveSet.has(i.group) && normalizeBool(i.options?.reflect) === true);
  const primitiveReflectFalseArr = items.filter(i => primitiveSet.has(i.group) && normalizeBool(i.options?.reflect) === false);
  const primitiveReflectTrue = count(primitiveReflectTrueArr);
  const primitiveReflectFalse = count(primitiveReflectFalseArr);

  // Future tests (not yet implemented): mutable behavior on primitives
  const primitiveMutableTrueArr = items.filter(i => primitiveSet.has(i.group) && normalizeBool(i.options?.mutable) === true);
  const primitiveMutableFalseArr = items.filter(i => primitiveSet.has(i.group) && normalizeBool(i.options?.mutable) === false);
  const primitiveMutableTrue = count(primitiveMutableTrueArr);
  const primitiveMutableFalse = count(primitiveMutableFalseArr);

  const caseNosFor = (arr) => {
    const s = new Set();
    for (const it of arr) {
      for (const n of (it.caseIds || [])) {
        s.add(n);
      }
    }
    return Array.from(s).sort((a, b) => a - b);
  };

  const primitiveCases = caseNosFor(groupIn(primitiveSet));
  const complexCases = caseNosFor(groupIn(complexSet));
  const reflectTrueCases = caseNosFor(primitiveReflectTrueArr);
  const reflectFalseCases = caseNosFor(primitiveReflectFalseArr);
  const mutableTrueCases = caseNosFor(primitiveMutableTrueArr);
  const mutableFalseCases = caseNosFor(primitiveMutableFalseArr);

  const hasCase = (arr, id) => Array.isArray(arr) && arr.includes(id);
  const case1Implemented = hasCase(primitiveCases, 1);
  const case2Implemented = hasCase(complexCases, 2);
  const case3Implemented = hasCase(reflectTrueCases, 3);
  const case4Implemented = hasCase(reflectFalseCases, 4);
  const mutableTrueImplemented = hasCase(mutableTrueCases, 5);
  const mutableFalseImplemented = hasCase(mutableFalseCases, 6);

  // Case counts are driven by caseIds, not explicit test titles
  const primitiveTestsCount = primitiveCases.length ? primitive.total : 0;
  const complexTestsCount = complexCases.length ? complex.total : 0;
  const reflectTrueTestsCount = reflectTrueCases.length ? primitiveReflectTrue.total : 0;
  const reflectFalseTestsCount = reflectFalseCases.length ? primitiveReflectFalse.total : 0;
  const mutableTrueTestsCount = mutableTrueCases.length ? primitiveMutableTrue.total : 0;
  const mutableFalseTestsCount = mutableFalseCases.length ? primitiveMutableFalse.total : 0;

  

  const allRows = [
    {
      id: 1,
      implemented: case1Implemented,
      desc: 'Runtime coverage for primitive prop types. Validate render, reflect, and mutability combinations.',
      types: (
        <>
          type: string | number | boolean × reflect: true/false × mutable: true/false<br/>
          <small>Covered: {primitive.tested}/{primitive.total}</small>
        </>
      ),
      tested: primitive.tested,
      total: primitive.total,
      section: case1Implemented ? 'implemented' : 'missing',
    },
    {
      id: 2,
      implemented: case2Implemented,
      desc: (
        <>
          Static render and reflection behavior for complex prop types (<code>Array</code>, <code>Object</code>, <code>Set</code>).<br/>
          <small>Tests: {complexTestsCount}</small>
        </>
      ),
      types: (
        <>
          type: Array | Object | Set × reflect: true/false × mutable: true/false<br/>
          <small>Covered: {complex.tested}/{complex.total}</small>
        </>
      ),
      tested: complex.tested,
      total: complex.total,
      section: case2Implemented ? 'implemented' : 'missing',
    },
    {
      id: 3,
      implemented: case3Implemented,
      desc: 'Reflect=true behavior for primitives: attribute presence/value matches prop updates.',
      types: (
        <>
          string | number | boolean × reflect: true<br/>
          <small>Covered: {primitiveReflectTrue.tested}/{primitiveReflectTrue.total}</small>
        </>
      ),
      tested: primitiveReflectTrue.tested,
      total: primitiveReflectTrue.total,
      section: case3Implemented ? 'implemented' : 'missing',
    },
    {
      id: 4,
      implemented: case4Implemented,
      desc: 'Reflect=false behavior for primitives: no attribute is reflected when prop updates.',
      types: (
        <>
          string | number | boolean × reflect: false<br/>
          <small>Covered: {primitiveReflectFalse.tested}/{primitiveReflectFalse.total}</small>
        </>
      ),
      tested: primitiveReflectFalse.tested,
      total: primitiveReflectFalse.total,
      section: case4Implemented ? 'implemented' : 'missing',
    },
    {
      id: 5,
      implemented: mutableTrueImplemented,
      desc: 'Mutable=true behavior for primitives: component can mutate its own prop without errors; verify DOM and attribute state.',
      types: (
        <>
          string | number | boolean × mutable: true<br/>
          <small>Covered: {primitiveMutableTrue.tested}/{primitiveMutableTrue.total}</small>
        </>
      ),
      tested: primitiveMutableTrue.tested,
      total: primitiveMutableTrue.total,
      section: mutableTrueImplemented ? 'implemented' : 'missing',
    },
    {
      id: 6,
      implemented: mutableFalseImplemented,
      desc: 'Mutable=false behavior for primitives: component-internal attempts to mutate are ignored; DOM and attribute remain stable.',
      types: (
        <>
          string | number | boolean × mutable: false<br/>
          <small>Covered: {primitiveMutableFalse.tested}/{primitiveMutableFalse.total}</small>
        </>
      ),
      tested: primitiveMutableFalse.tested,
      total: primitiveMutableFalse.total,
      section: mutableFalseImplemented ? 'implemented' : 'missing',
    },
  ];

  const missingRows = allRows.filter(r => !r.implemented);
  const implementedRows = allRows.filter(r => r.implemented);
  const orderedRows = [...missingRows, ...implementedRows];
  const totalRows = orderedRows.length;

  const [expanded, setExpanded] = useState(false);
  const rowsToRender = expanded ? orderedRows : orderedRows.slice(0, 3);

  const renderStatus = (r) => {
    if (!r.implemented) {
      return <em>—</em>;
    }
    const ok = r.total > 0 && r.tested === r.total;
    return (
      <span style={{ color: ok ? 'green' : '#999' }}>{r.total > 0 ? (ok ? '✔' : '✗') : '—'}</span>
    );
  };

  const renderCaseRow = (r, idx) => (
    <tr key={r.id} style={idx % 2 === 1 ? { background: '#f9f9f9' } : undefined}>
      <td style={{ padding: '8px', border: '1px solid #ddd' }}>#{r.id}</td>
      <td style={{ padding: '8px', border: '1px solid #ddd' }}>{r.desc}</td>
      <td style={{ padding: '8px', border: '1px solid #ddd' }}>{r.types}</td>
      <td style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>{renderStatus(r)}</td>
    </tr>
  );

  const renderSectionedRows = (rows) => {
    const out = [];
    let lastSection = null;
    rows.forEach((r, i) => {
      if (r.section !== lastSection) {
        out.push(
          <tr key={`section-${r.section}-${i}`}>
            <td colSpan={4} style={{ padding: '8px', border: '1px solid #ddd', background: r.section === 'missing' ? '#fff4e5' : '#eef7ee', fontWeight: 600 }}>
              {r.section === 'missing' ? 'Not Implemented' : 'Implemented'}
            </td>
          </tr>
        );
        lastSection = r.section;
      }
      out.push(renderCaseRow(r, i));
    });
    return out;
  };

  return (
    <div style={{ maxWidth: '100%', width: '100%', background: '#fff', position: 'relative' }}>
      <table style={{ width: '100%', borderCollapse: 'collapse' }}>
        <colgroup>
          <col style={{ width: '15%' }} />
          <col style={{ width: '55%' }} />
          <col style={{ width: '20%' }} />
          <col style={{ width: '10%' }} />
        </colgroup>
        <thead>
          <tr style={{ background: '#f2f2f2' }}>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Test Case #</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Description</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Types Covered</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>Status</th>
          </tr>
        </thead>
        <tbody>{renderSectionedRows(rowsToRender)}</tbody>
      </table>
      {!expanded && totalRows > 3 && (
        <>
          <div
            style={{
              position: 'absolute',
              left: 0,
              right: 0,
              bottom: 40,
              height: 48,
              background: 'linear-gradient(180deg, rgba(255,255,255,0) 0%, #fff 90%)',
              pointerEvents: 'none',
            }}
          />
          <div style={{ display: 'flex', justifyContent: 'center', marginTop: 8 }}>
            <button
              onClick={() => setExpanded(true)}
              style={{
                padding: '6px 12px',
                border: '1px solid #ddd',
                background: '#f8f8f8',
                borderRadius: 4,
                cursor: 'pointer',
                fontSize: 12,
              }}
              aria-label={`Show all ${totalRows} test cases`}
            >
              Show all {totalRows} test cases
            </button>
          </div>
        </>
      )}
      {expanded && (
        <div style={{ display: 'flex', justifyContent: 'flex-end', marginTop: 8 }}>
          <button
            onClick={() => setExpanded(false)}
            style={{
              padding: '6px 12px',
              border: '1px solid #ddd',
              background: '#f8f8f8',
              borderRadius: 4,
              cursor: 'pointer',
              fontSize: 12,
            }}
            aria-label="Collapse test cases table"
          >
            Collapse table
          </button>
        </div>
      )}
    </div>
  );
};

<PropTestCasesTable />

## Generated Components

<div>
  <strong>Generated Components:</strong> {data.coverage.covered} of {data.coverage.total} generated (
  <strong>{data.coverage.percent}%</strong>)
</div>

<p style={{ marginTop: 8 }}>
  This section lists the generated components we build to stress the compiler. Each row is one component with a
  unique combination of decorator options (<code>type</code> × <code>reflect</code> × <code>mutable</code>). If a combo fails to compile,
  we capture that as a rule in <code>rules.json</code>, update the list, and regenerate. The “Tested By” column reflects which
  high‑level test cases cover each component.
</p>

export const GeneratedComponentsTable = () => {
  const [expanded, setExpanded] = useState(false);

  const rows = useMemo(() => {
    const items = overlay.items || [];
    const map = new Map(items.map(i => [i.optionsKey, i]));
    return (data.coveredPermutations || []).map((p, i) => {
      const [type, reflect, mutable] = p.options || [];
      const key = (p.options || []).join('|');
      const oi = map.get(key) || {};
      const caseNumbers = Array.isArray(oi.caseIds) ? [...oi.caseIds].sort((a,b) => a-b) : [];
      return {
        index: i,
        type,
        reflect,
        mutable,
        caseNumbers,
      };
    });
  }, []);

  const total = rows.length;

  const renderTable = (rowsToRender) => (
    <div style={{ maxWidth: '100%', width: '100%', background: '#fff' }}>
      <table style={{ width: '100%', borderCollapse: 'collapse', tableLayout: 'fixed' }}>
        <colgroup>
          <col style={{ width: '30%' }} />
          <col style={{ width: '20%' }} />
          <col style={{ width: '20%' }} />
          <col style={{ width: '30%' }} />
        </colgroup>
        <thead>
          <tr>
            <th>Type</th>
            <th>reflect</th>
            <th>mutable</th>
            <th>Tested By</th>
          </tr>
        </thead>
        <tbody>
          {rowsToRender.map((r) => (
            <tr key={r.index}>
              <td>{r.type}</td>
              <td>{r.reflect}</td>
              <td>{r.mutable}</td>
              <td>
                {r.caseNumbers && r.caseNumbers.length
                  ? (
                      r.caseNumbers.length === 1
                        ? `#${r.caseNumbers[0]}`
                        : r.caseNumbers.join(' & ')
                    )
                  : <em>—</em>}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );

  if (!expanded) {
    const preview = rows.slice(0, 3);
    return (
      <div style={{ position: 'relative' }}>
        {renderTable(preview)}
        {total > 3 && (
          <>
            <div
              style={{
                position: 'absolute',
                left: 0,
                right: 0,
                bottom: 40,
                height: 48,
                background: 'linear-gradient(180deg, rgba(255,255,255,0) 0%, #fff 90%)',
                pointerEvents: 'none',
              }}
            />
            <div style={{ display: 'flex', justifyContent: 'center', marginTop: -8 }}>
              <button
                onClick={() => setExpanded(true)}
                style={{
                  padding: '6px 12px',
                  border: '1px solid #ddd',
                  background: '#f8f8f8',
                  borderRadius: 4,
                  cursor: 'pointer',
                  fontSize: 12,
                }}
                aria-label={`Show all ${total} components`}
              >
                Show all {total} components
              </button>
            </div>
          </>
        )}
      </div>
    );
  }

  return (
    <div>
      <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: 8 }}>
        <button
          onClick={() => setExpanded(false)}
          style={{
            padding: '6px 12px',
            border: '1px solid #ddd',
            background: '#f8f8f8',
            borderRadius: 4,
            cursor: 'pointer',
            fontSize: 12,
          }}
          aria-label="Collapse components table"
        >
          Collapse table
        </button>
      </div>
      {renderTable(rows)}
    </div>
  );
};

<GeneratedComponentsTable />

## Component Grouping

Generated components are organized by prop type under `test/wdio/prop/components/`:

- `string/` — string props
- `number/` — numeric props
- `boolean/` — boolean props
- `Array/` — array props
- `Object/` — object props
- `Set/` — set props

