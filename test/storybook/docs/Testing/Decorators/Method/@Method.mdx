import rules from './data/rules.json';
import { Meta } from '@storybook/addon-docs/blocks';
import data from './data/components.json';
import overlay from './data/test-coverage.json';
import React, { useMemo, useState } from 'react';
import RulesAtAGlance from '../_shared/RulesAtAGlance.jsx';
import TestCasesTable from '../_shared/TestCasesTable.jsx';
import GeneratedComponentsTable from '../_shared/GeneratedComponentsTable.jsx';

<Meta title="Testing/Decorators/@Method"/>

# @Method Decorator

The `@Method` decorator exposes public instance methods on a Stencil component.

## Decorator Properties

- returns: void | value | promise
- async: marks the method async (affects return type when returning a promise)
- args: none | one

## Rules (at a glance)
<RulesAtAGlance rules={rules} sourcePath="./data/rules.json" modeLabel="Return kind" />

## Test Cases

Note: Test cases are high‑level scenarios, not a 1‑to‑1 mapping to tests (it() blocks). A single WDIO test can exercise many generated components, and a component can participate in multiple tests. The "Tested By" column in the Generated Components table shows which case(s) (#1, #2) each component is covered by. All @Method tests reside under <code>test/wdio/method</code>.

export const MethodTestCasesTable = () => {
  const items = overlay.items || [];
  const groupIn = (set) => items.filter(i => set.has(i.group));
  const count = (arr) => ({ tested: arr.filter(i => i.tested).length, total: arr.length });

  const promiseSet = new Set(['promise']);
  const valueSet = new Set(['value']);
  const voidSet = new Set(['void']);

  const promise = count(groupIn(promiseSet));
  const value = count(groupIn(valueSet));
  const void_ = count(groupIn(voidSet));

  const caseNosFor = (arr) => {
    const s = new Set();
    for (const it of arr) {
      for (const n of (it.caseIds || [])) {
        s.add(n);
      }
    }
    return Array.from(s).sort((a, b) => a - b);
  };

  const promiseCases = caseNosFor(groupIn(promiseSet));
  const valueCases = caseNosFor(groupIn(valueSet));
  const voidCases = caseNosFor(groupIn(voidSet));

  const case1Implemented = promiseCases.length > 0;
  const case2Implemented = valueCases.length > 0;
  const case3Implemented = voidCases.length > 0;

  const rows = [
    {
      id: 1,
      implemented: case1Implemented,
      desc: 'Promise methods expose public API and update DOM after resolution across different async configurations and argument patterns.',
      types: (
        <>
          returns: promise × async: true/false × args: none/one<br/>
          <small>Covered: {promise.tested}/{promise.total}</small>
        </>
      ),
      tested: promise.tested,
      total: promise.total,
    },
    {
      id: 2,
      implemented: case2Implemented,
      desc: 'Value-returning methods provide immediate results and update component state synchronously.',
      types: (
        <>
          returns: value × async: true × args: none/one<br/>
          <small>Covered: {value.tested}/{value.total}</small>
        </>
      ),
      tested: value.tested,
      total: value.total,
    },
    {
      id: 3,
      implemented: case3Implemented,
      desc: 'Void methods trigger side effects without return values, updating internal state via async lifecycle.',
      types: (
        <>
          returns: void × async: true × args: none/one<br/>
          <small>Covered: {void_.tested}/{void_.total}</small>
        </>
      ),
      tested: void_.tested,
      total: void_.total,
    },
  ];

  return <TestCasesTable rows={rows} previewCount={3} />;
};

<MethodTestCasesTable />

## Generated Components

<div>
  <strong>Generated Components:</strong> {data.coverage.covered} of {data.coverage.total} generated (
  <strong>{data.coverage.percent}%</strong>)
</div>

<p style={{ marginTop: 8 }}>
  This section lists the generated components we build to stress the compiler. Each row is one component with a
  unique combination of decorator options (<code>returns</code> × <code>async</code> × <code>args</code>). If a combo fails to compile,
  we capture that as a rule in <code>rules.json</code>, update the list, and regenerate. The "Tested By" column reflects which
  high‑level test cases cover each component.
</p>

export const MethodGeneratedComponents = () => {
  const rows = useMemo(() => {
    const items = overlay.items || [];
    const map = new Map(items.map(i => [i.optionsKey, i]));
    return (data.coveredPermutations || []).map((p, i) => {
      const [returns, async, args] = p.options || [];
      const key = (p.options || []).join('|');
      const oi = map.get(key) || {};
      const caseNumbers = Array.isArray(oi.caseIds) ? [...oi.caseIds].sort((a,b) => a-b) : [];
      return {
        index: i,
        returns,
        async,
        args,
        caseNumbers,
      };
    });
  }, []);

  const columns = [
    { key: 'returns', label: 'Returns', width: '25%' },
    { key: 'async', label: 'Async', width: '20%' },
    { key: 'args', label: 'Args', width: '20%' },
    { key: 'testedBy', label: 'Tested By', width: '35%' },
  ];

  return <GeneratedComponentsTable rows={rows} columns={columns} previewCount={3} />;
};

<MethodGeneratedComponents />

## Component Grouping

Generated components are organized by return type under `test/wdio/method/components/`:

- `void/` — void-returning methods
- `value/` — value-returning methods
- `promise/` — promise-returning methods

