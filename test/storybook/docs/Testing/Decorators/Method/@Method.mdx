import rules from './data/rules.json';
import { Meta } from '@storybook/addon-docs/blocks';
import data from './data/components.json';
import overlay from './data/test-coverage.json';
import React, { useMemo, useState } from 'react';
import RulesAtAGlance from '../_shared/RulesAtAGlance.jsx';
import TestCasesTable from '../_shared/TestCasesTable.jsx';
import GeneratedComponentsTable from '../_shared/GeneratedComponentsTable.jsx';

<Meta title="Testing/Decorators/@Method"/>

# @Method Decorator

The `@Method` decorator exposes public instance methods on a Stencil component. This page documents the test coverage, patterns, generated components, and implementation status.

## Decorator Properties

- returns: void | value | promise
- async: marks the method async (affects return type when returning a promise)
- args: none | one

## Rules (at a glance)
<RulesAtAGlance rules={rules} sourcePath="./data/rules.json" modeLabel="Return kind" />

## Test Cases

Test cases are organized by **return type** and **behavioral patterns** - from promise-returning methods to void methods, and from basic method calls to inheritance scenarios. `@Method` tests are located throughout the <code>test/wdio</code> directory, with the core generated components in <code>test/wdio/method</code> and additional real-world scenarios in other test directories.

export const MethodCoverageSummary = () => {
  const testCaseStatus = overlay.testCaseStatus || {};
  const testCases = Object.values(testCaseStatus);
  const implementedCases = testCases.filter(tc => tc.implemented).length;
  const totalCases = testCases.length || 3; // Fallback to 3 if no testCaseStatus
  const coveragePercentage = totalCases > 0 ? Math.round((implementedCases / totalCases) * 100) : 0;
  const totalTests = testCases.reduce((sum, tc) => sum + (tc.testCount || 0), 0);
  
  return (
    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '20px', marginBottom: '32px' }}>
      <div style={{ 
        background: '#fff', 
        padding: '20px', 
        borderRadius: '8px', 
        border: '2px solid #e5e7eb',
        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
      }}>
        <div style={{ fontSize: '13px', fontWeight: '600', color: '#6b7280', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '8px' }}>
          Test Cases Implemented
        </div>
        <div style={{ fontSize: '36px', fontWeight: '700', color: '#111827', lineHeight: '1', marginBottom: '6px' }}>
          {implementedCases}<span style={{ color: '#d1d5db' }}>/{totalCases}</span>
        </div>
        <div style={{ fontSize: '13px', color: '#6b7280' }}>
          {coveragePercentage}% complete
        </div>
      </div>
      
      <div style={{ 
        background: '#fff', 
        padding: '20px', 
        borderRadius: '8px', 
        border: '2px solid #e5e7eb',
        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
      }}>
        <div style={{ fontSize: '13px', fontWeight: '600', color: '#6b7280', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '8px' }}>
          Total Tests
        </div>
        <div style={{ fontSize: '36px', fontWeight: '700', color: '#111827', lineHeight: '1', marginBottom: '6px' }}>
          {totalTests}
        </div>
        <div style={{ fontSize: '13px', color: '#6b7280', borderTop: '1px solid #e5e7eb', paddingTop: '8px', marginTop: '8px' }}>
          ðŸ“… Last run: {overlay.lastRunFormatted || 'Never'}
        </div>
      </div>
    </div>
  );
};

<MethodCoverageSummary />

export const MethodTestCasesTable = () => {
  const testCaseStatus = overlay.testCaseStatus || {};
  const allCaseIds = Object.keys(testCaseStatus).map(id => parseInt(id)).sort((a, b) => a - b);
  
  const rows = allCaseIds.map(caseId => {
    const status = testCaseStatus[caseId];
    const caseDescriptions = {
      1: 'Promise methods expose public API and update DOM after resolution across different async configurations and argument patterns.',
      2: 'Value-returning methods provide immediate results and update component state synchronously.',
      3: 'Void methods trigger side effects without return values, updating internal state via async lifecycle.',
      4: 'Method inheritance basics - methods inherited from base classes, super() calls, method override, and method composition.',
      5: 'Methods with state management - methods that update component state and trigger re-renders.',
      6: 'Methods returning component instances - methods that return component instances for testing/debugging.',
      7: 'Methods with DOM/slot interaction - methods that interact with slot elements (assignedElements, assignedNodes).',
      8: 'Methods with event emission - methods that emit events.',
      9: 'Methods with dynamic imports - methods that use dynamic imports.',
      10: 'Methods with focus/blur handling - methods that handle focus/blur events.',
      11: 'Methods in props/state inheritance - methods that update inherited props and state.',
      12: 'Methods in mixin inheritance - methods in mixin-based inheritance scenarios.',
      13: 'Methods in external component inheritance - methods in external component inheritance.',
      14: 'Methods in component inheritance - methods in component-to-component inheritance.',
      15: 'Methods in abstract class inheritance - methods in abstract class inheritance.',
    };
    
    return {
      id: caseId,
      implemented: status.implemented,
      desc: caseDescriptions[caseId] || `Test Case #${caseId}`,
      types: (
        <>
          Components: {status.componentCount || 0}<br/>
          <small>Tests: {status.testCount || 0}</small>
        </>
      ),
      tested: status.testCount || 0,
      total: status.componentCount || 0,
      section: status.implemented ? 'implemented' : 'missing',
      testCount: status.testCount || 0,
    };
  });

  return <TestCasesTable rows={rows} previewCount={15} />;
};

<MethodTestCasesTable />

## Generated Components

<div>
  <strong>Generated Components:</strong> {data.coverage.covered} of {data.coverage.total} generated (
  <strong>{data.coverage.percent}%</strong>)
</div>

<p style={{ marginTop: 8 }}>
  This section lists the generated components we build to stress the compiler. Each row is one component with a
  unique combination of decorator options (<code>returns</code> Ã— <code>async</code> Ã— <code>args</code>). If a combo fails to compile,
  we capture that as a rule in <code>rules.json</code>, update the list, and regenerate. The "Tested By" column reflects which
  highâ€‘level test cases cover each component.
</p>

export const MethodGeneratedComponents = () => {
  const rows = useMemo(() => {
    const items = overlay.items || [];
    const map = new Map(items.map(i => [i.optionsKey, i]));
    return (data.coveredPermutations || []).map((p, i) => {
      const [returns, async, args] = p.options || [];
      const key = (p.options || []).join('|');
      const oi = map.get(key) || {};
      const caseNumbers = Array.isArray(oi.caseIds) ? [...oi.caseIds].sort((a,b) => a-b) : [];
      return {
        index: i,
        returns,
        async,
        args,
        caseNumbers,
      };
    });
  }, []);

  const columns = [
    { key: 'returns', label: 'Returns', width: '25%' },
    { key: 'async', label: 'Async', width: '20%' },
    { key: 'args', label: 'Args', width: '20%' },
    { key: 'testedBy', label: 'Tested By', width: '35%' },
  ];

  return <GeneratedComponentsTable rows={rows} columns={columns} previewCount={3} />;
};

<MethodGeneratedComponents />

---

## Test Categories

### **ðŸŸ¡ Basic Method Types (1-3)** â€” 3 test cases
Core method return types covering promise, value, and void methods with various async and argument configurations.

- **Test Case #1 - Promise Methods**: Promise-returning methods that expose public API and update DOM after resolution, covering async configurations and argument patterns. Tests located in `test/wdio/method/tests.tsx`.
- **Test Case #2 - Value Methods**: Value-returning methods that provide immediate results and update component state synchronously. Tests located in `test/wdio/method/tests.tsx`.
- **Test Case #3 - Void Methods**: Void methods that trigger side effects without return values, updating internal state via async lifecycle. Tests located in `test/wdio/method/tests.tsx`.

### **ðŸŸ¡ Method Inheritance (4)** â€” 1 test case
Methods in inheritance scenarios, including base class methods, super() calls, method override, and composition.

- **Test Case #4 - Method Inheritance Basics**: Tests for @Method decorator inheritance, super() calls, method override, and method composition. Tests located in `test/wdio/ts-target/extends-methods/cmp.test.ts`.

### **ðŸŸ¡ State Management Methods (5)** â€” 1 test case
Methods that update component state and trigger re-renders.

- **Test Case #5 - Methods with State Management**: Methods that update component state and trigger re-renders. Components: `attribute-boolean-root`, `computed-properties-state-decorator`. Tests located in `test/wdio/attribute-boolean/cmp.test.tsx` and `test/wdio/computed-properties-state-decorator/cmp.test.tsx`.

### **ðŸŸ¡ Instance Return Methods (6)** â€” 1 test case
Methods that return component instances for testing or debugging purposes.

- **Test Case #6 - Methods Returning Component Instances**: Methods that return component instances for testing/debugging. Component: `attribute-complex`. Tests located in `test/wdio/attribute-complex/cmp.test.tsx`.

### **ðŸŸ¡ DOM/Slot Interaction Methods (7)** â€” 1 test case
Methods that interact with DOM elements, particularly slot elements.

- **Test Case #7 - Methods with DOM/Slot Interaction**: Methods that interact with slot elements (assignedElements, assignedNodes). Component: `scoped-slot-assigned-methods`. Tests located in `test/wdio/scoped-slot-assigned-methods/cmp.test.tsx`.

### **ðŸŸ¡ Event Emission Methods (8)** â€” 1 test case
Methods that emit events.

- **Test Case #8 - Methods with Event Emission**: Methods that emit events. Component: `esm-import`. Tests located in `test/wdio/esm-import/cmp.test.tsx`.

### **ðŸŸ¡ Dynamic Import Methods (9)** â€” 1 test case
Methods that use dynamic imports.

- **Test Case #9 - Methods with Dynamic Imports**: Methods that use dynamic imports. Component: `dynamic-import`. Tests located in `test/wdio/dynamic-imports/cmp.test.tsx`.

### **ðŸŸ¡ Focus/Blur Handling Methods (10)** â€” 1 test case
Methods that handle focus and blur events.

- **Test Case #10 - Methods with Focus/Blur Handling**: Methods that handle focus/blur events. Component: `ion-radio`. Tests located in `test/wdio/radio-group-blur/cmp.test.tsx`.

### **ðŸŸ¡ Inheritance Scenarios (11-15)** â€” 5 test cases
Methods in various inheritance scenarios, including props/state inheritance, mixin inheritance, external component inheritance, component inheritance, and abstract class inheritance.

- **Test Case #11 - Methods in Props/State Inheritance**: Methods that update inherited props and state. Component: `extends-props-state`. Tests located in `test/wdio/ts-target/extends-props-state/cmp.test.ts`.
- **Test Case #12 - Methods in Mixin Inheritance**: Methods in mixin-based inheritance scenarios. Components: `extends-mixin-cmp`, `mixin-a`, `mixin-b`. Tests located in `test/wdio/ts-target/extends-mixin/cmp.test.ts`.
- **Test Case #13 - Methods in External Component Inheritance**: Methods in external component inheritance. Components: `extends-external`, `sibling-extended-base`. Tests located in `test/wdio/ts-target/extends-external/cmp.test.ts`.
- **Test Case #14 - Methods in Component Inheritance**: Methods in component-to-component inheritance. Components: `extends-cmp-cmp`, `extended-cmp`. Tests located in `test/wdio/ts-target/extends-cmp/cmp.test.ts`.
- **Test Case #15 - Methods in Abstract Class Inheritance**: Methods in abstract class inheritance. Components: `extends-abstract`, `mixin-parent`. Tests located in `test/wdio/ts-target/extends-abstract/cmp.test.ts`.

---

export const MethodTODOSection = () => {
  const testCaseStatus = overlay.testCaseStatus || {};
  const allCaseIds = Object.keys(testCaseStatus).map(id => parseInt(id)).sort((a, b) => a - b);
  
  const missingCases = allCaseIds
    .filter(caseId => !testCaseStatus[caseId].implemented)
    .map(caseId => ({
      id: caseId,
      desc: `Test Case #${caseId} - Not yet implemented`
    }));
  
  if (missingCases.length === 0) {
    return null;
  }
  
  return (
    <div>
      {missingCases.map(({ id, desc }) => (
        <div key={id} style={{ marginBottom: '12px' }}>
          <strong>Test Case #{id} TODO</strong>: {desc}
        </div>
      ))}
    </div>
  );
};

{(() => {
  const testCaseStatus = overlay.testCaseStatus || {};
  const allCaseIds = Object.keys(testCaseStatus).map(id => parseInt(id)).sort((a, b) => a - b);
  const implementedCases = allCaseIds.filter(caseId => testCaseStatus[caseId].implemented);
  
  if (implementedCases.length === allCaseIds.length) return null;
  return (
    <>
      <h2>ðŸ“‹ TODO - Remaining Test Cases</h2>
      <MethodTODOSection />
    </>
  );
})()}

---

## Component Grouping

Generated components are organized by return type under `test/wdio/method/components/`:

- `void/` â€” void-returning methods
- `value/` â€” value-returning methods
- `promise/` â€” promise-returning methods

Additional components with `@Method` decorators are located throughout the `test/wdio` directory:

- `test/wdio/attribute-boolean/` â€” State management methods
- `test/wdio/computed-properties-state-decorator/` â€” Computed state methods
- `test/wdio/attribute-complex/` â€” Instance return methods
- `test/wdio/scoped-slot-assigned-methods/` â€” Slot interaction methods
- `test/wdio/esm-import/` â€” Event emission methods
- `test/wdio/dynamic-imports/` â€” Dynamic import methods
- `test/wdio/radio-group-blur/` â€” Focus/blur handling methods
- `test/wdio/ts-target/extends-*/` â€” Inheritance scenario methods

