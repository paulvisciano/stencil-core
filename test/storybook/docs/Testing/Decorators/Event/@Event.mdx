import rules from './data/rules.json';
import { Meta } from '@storybook/addon-docs/blocks';
import data from './data/components.json';
import testCoverage from './data/test-coverage.json';
import React from 'react';
import RulesAtAGlance from '../_shared/RulesAtAGlance.jsx';
import TestCasesTable from '../_shared/TestCasesTable.jsx';
import GeneratedComponentsTable from '../_shared/GeneratedComponentsTable.jsx';

<Meta title="Testing/Decorators/@Event"/>

# @Event Decorator

The `@Event` decorator defines a custom event that components can emit. This page documents the decorator properties, rules, test cases, generated components, and component grouping.

## Decorator Properties

- **bubbles**: if true, the event bubbles up through the DOM hierarchy
- **cancelable**: if true, the event can be canceled with `event.preventDefault()`
- **composed**: if true, the event can pass through shadow DOM boundaries

## Rules
<RulesAtAGlance rules={rules} sourcePath="./data/rules.json" modeLabel="Event mode" />

## Test Cases

Note: Test cases are high-level scenarios, not a 1-to-1 mapping to tests (it() blocks). A single WDIO test can exercise many generated components, and a component can participate in multiple tests. All @Event tests reside under `test/wdio/event`.

export const EventTestCasesTable = () => {
  // Get items from test coverage data
  const items = testCoverage.items || [];
  
  // Group by case ID (1 = bubbling, 2 = non-bubbling)
  const bubblingItems = items.filter(item => item.caseIds && item.caseIds.includes(1));
  const nonBubblingItems = items.filter(item => item.caseIds && item.caseIds.includes(2));

  const testCaseRows = [
    {
      id: 1,
      desc: "Bubbling events – Tests event emission and handling for events that bubble up the DOM hierarchy",
      types: "4 components with bubbles=true (all cancelable/composed combinations)",
      implemented: bubblingItems.some(item => item.tested),
      tested: bubblingItems.filter(item => item.tested).length,
      total: bubblingItems.length
    },
    {
      id: 2,
      desc: "Non-bubbling events – Tests event emission and handling for events isolated to their target element", 
      types: "4 components with bubbles=false (all cancelable/composed combinations)",
      implemented: nonBubblingItems.some(item => item.tested),
      tested: nonBubblingItems.filter(item => item.tested).length,
      total: nonBubblingItems.length
    }
  ];
  
  return <TestCasesTable rows={testCaseRows} />;
};

<EventTestCasesTable />

## Generated Components

export const EventGeneratedComponentsTable = () => {
  // Use the items from test coverage which has the caseIds information
  const rows = (testCoverage.items || []).map((item, index) => {
    return {
      index: index,
      bubbles: item.options?.bubbles === '✓' ? 'true' : 'false',
      cancelable: item.options?.cancelable === '✓' ? 'true' : 'false', 
      composed: item.options?.composed === '✓' ? 'true' : 'false',
      caseNumbers: Array.isArray(item.caseIds) ? [...item.caseIds].sort((a, b) => a - b) : []
    };
  });
  
  const columns = [
    { key: 'bubbles', label: 'Bubbles', width: '25%' },
    { key: 'cancelable', label: 'Cancelable', width: '25%' },
    { key: 'composed', label: 'Composed', width: '25%' },
    { key: 'testedBy', label: 'Tested By', width: '25%' },
  ];
  
  return <GeneratedComponentsTable rows={rows} columns={columns} previewCount={3} />;
};

<EventGeneratedComponentsTable />

## Component Grouping

Components are grouped by **bubbles** mode under `/test/wdio/event/components/<bubbles|no-bubbles>/`. This organization reflects whether the event bubbles up through the DOM hierarchy or remains isolated to its target element.