import rules from './data/rules.json';
import { Meta } from '@storybook/addon-docs/blocks';
import data from './data/components.json';
import overlay from './data/test-coverage.json';
import React, { useMemo, useState } from 'react';
import RulesAtAGlance from '../_shared/RulesAtAGlance.jsx';
import TestCasesTable from '../_shared/TestCasesTable.jsx';
import GeneratedComponentsTable from '../_shared/GeneratedComponentsTable.jsx';

<Meta title="Testing/Decorators/@Listen"/>

# @Listen Decorator

The `@Listen` decorator wires an event listener to a target (host, window, document, or body). This page documents the test coverage, patterns, generated components, and implementation status.

## Decorator Properties

- **target**: where to listen (default: host) - can be `host`, `window`, `document`, or `body`
- **event**: the event name (e.g., `click`, `keydown`, `input`)
- **capture**: use capture phase when true
- **passive**: mark listener as passive when true

## Rules (at a glance)
<RulesAtAGlance rules={rules} sourcePath="./data/rules.json" modeLabel="Listen target" />

## Test Cases

Test cases for `@Listen` are organized by **target and event behavior** - from basic host events to global window/document/body listeners with capture and passive options. All `@Listen` tests reside under <code>test/wdio/listen</code>.

export const ListenCoverageSummary = () => {
  const testCaseStatus = overlay.testCaseStatus || {};
  const testCases = Object.values(testCaseStatus);
  const implementedCases = testCases.filter(tc => tc.implemented).length;
  const totalCases = testCases.length;
  const coveragePercentage = totalCases > 0 ? Math.round((implementedCases / totalCases) * 100) : 0;
  const totalTests = testCases.reduce((sum, tc) => sum + (tc.testCount || 0), 0);
  
  // If no test cases defined yet, show component coverage instead
  if (totalCases === 0) {
    const items = overlay.items || [];
    const testedCount = items.filter(item => item.tested).length;
    const totalComponents = items.length;
    return (
      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '20px', marginBottom: '32px' }}>
        <div style={{ 
          background: '#fff', 
          padding: '20px', 
          borderRadius: '8px', 
          border: '2px solid #e5e7eb',
          boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
        }}>
          <div style={{ fontSize: '13px', fontWeight: '600', color: '#6b7280', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '8px' }}>
            Components Tested
          </div>
          <div style={{ fontSize: '36px', fontWeight: '700', color: '#111827', lineHeight: '1', marginBottom: '6px' }}>
            {testedCount}<span style={{ color: '#d1d5db' }}>/{totalComponents}</span>
          </div>
          <div style={{ fontSize: '13px', color: '#6b7280' }}>
            {totalComponents > 0 ? Math.round((testedCount / totalComponents) * 100) : 0}% complete
          </div>
        </div>
        
        <div style={{ 
          background: '#f0fdf4', 
          padding: '20px', 
          borderRadius: '8px', 
          border: '2px solid #86efac',
          boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
        }}>
          <div style={{ fontSize: '13px', fontWeight: '600', color: '#15803d', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '8px' }}>
            Total Components
          </div>
          <div style={{ fontSize: '36px', fontWeight: '700', color: '#16a34a', lineHeight: '1', marginBottom: '6px' }}>
            {totalComponents}
          </div>
          <div style={{ fontSize: '13px', color: '#15803d', marginBottom: '8px' }}>
            Generated components
          </div>
        </div>
      </div>
    );
  }
  
  return (
    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '20px', marginBottom: '32px' }}>
      <div style={{ 
        background: '#fff', 
        padding: '20px', 
        borderRadius: '8px', 
        border: '2px solid #e5e7eb',
        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
      }}>
        <div style={{ fontSize: '13px', fontWeight: '600', color: '#6b7280', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '8px' }}>
          Test Cases Implemented
        </div>
        <div style={{ fontSize: '36px', fontWeight: '700', color: '#111827', lineHeight: '1', marginBottom: '6px' }}>
          {implementedCases}<span style={{ color: '#d1d5db' }}>/{totalCases}</span>
        </div>
        <div style={{ fontSize: '13px', color: '#6b7280' }}>
          {coveragePercentage}% complete
        </div>
      </div>
      
      <div style={{ 
        background: '#f0fdf4', 
        padding: '20px', 
        borderRadius: '8px', 
        border: '2px solid #86efac',
        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
      }}>
        <div style={{ fontSize: '13px', fontWeight: '600', color: '#15803d', textTransform: 'uppercase', letterSpacing: '0.5px', marginBottom: '8px' }}>
          Total Tests Passing
        </div>
        <div style={{ fontSize: '36px', fontWeight: '700', color: '#16a34a', lineHeight: '1', marginBottom: '6px' }}>
          {totalTests}
        </div>
        <div style={{ fontSize: '13px', color: '#15803d', marginBottom: '8px' }}>
          All tests passing âœ“
        </div>
      </div>
    </div>
  );
};

<ListenCoverageSummary />

## Test Cases

Test cases are organized by **target and behavior** - from basic host element listeners to global targets with capture and passive options. All `@Listen` tests reside under <code>test/wdio/listen</code>.

export const ListenTestCasesTable = () => {
  const testCaseStatus = overlay.testCaseStatus || {};
  const items = overlay.items || [];
  
  // Helper function to get stats for a test case
  const getCaseStats = (caseId) => {
    const caseItems = items.filter(i => i.caseIds && i.caseIds.includes(caseId));
    return {
      tested: caseItems.filter(i => i.tested).length,
      total: caseItems.length
    };
  };
  
  // Helper function to format test count display
  const formatTestCount = (testCase) => {
    if (!testCase?.testCount) return '';
    return `${testCase.testCount} tests`;
  };

  const allRows = [
    {
      id: 1,
      implemented: testCaseStatus[1]?.implemented || false,
      desc: testCaseStatus[1]?.description || 'Host target events - listeners attached to the host element',
      types: (
        <>
          <strong>ðŸŸ¢ Basic:</strong> Host target events with all event types and capture/passive combinations<br/>
          <strong>Coverage:</strong> click, input, keydown events Ã— capture: true/false Ã— passive: true/false<br/>
          <small>Uses Host Element Pattern | {formatTestCount(testCaseStatus[1])}</small>
        </>
      ),
      tested: getCaseStats(1).tested,
      total: getCaseStats(1).total,
      testCount: testCaseStatus[1]?.testCount || 0,
      section: testCaseStatus[1]?.implemented ? 'implemented' : 'missing',
    },
    {
      id: 2,
      implemented: testCaseStatus[2]?.implemented || false,
      desc: testCaseStatus[2]?.description || 'Global target events - listeners attached to window, document, or body',
      types: (
        <>
          <strong>ðŸŸ¡ Standard:</strong> Global target events (window, document, body) with all event types<br/>
          <strong>Coverage:</strong> window/document/body Ã— click/keydown/input Ã— capture: true/false Ã— passive: true/false<br/>
          <small>Uses Global Target Pattern | {formatTestCount(testCaseStatus[2])}</small>
        </>
      ),
      tested: getCaseStats(2).tested,
      total: getCaseStats(2).total,
      testCount: testCaseStatus[2]?.testCount || 0,
      section: testCaseStatus[2]?.implemented ? 'implemented' : 'missing',
    },
    {
      id: 3,
      implemented: testCaseStatus[3]?.implemented || false,
      desc: testCaseStatus[3]?.description || 'Capture phase behavior - testing capture=true vs capture=false',
      types: (
        <>
          <strong>ðŸŸ¡ Standard:</strong> Capture phase behavior across all targets and events<br/>
          <strong>Coverage:</strong> capture: true/false behavior verification<br/>
          <small>Event capture phase testing | {formatTestCount(testCaseStatus[3])}</small>
        </>
      ),
      tested: getCaseStats(3).tested,
      total: getCaseStats(3).total,
      testCount: testCaseStatus[3]?.testCount || 0,
      section: testCaseStatus[3]?.implemented ? 'implemented' : 'missing',
    },
    {
      id: 4,
      implemented: testCaseStatus[4]?.implemented || false,
      desc: testCaseStatus[4]?.description || 'Passive listener behavior - testing passive=true vs passive=false',
      types: (
        <>
          <strong>ðŸŸ¡ Standard:</strong> Passive listener behavior across all targets and events<br/>
          <strong>Coverage:</strong> passive: true/false behavior verification<br/>
          <small>Passive listener optimization testing | {formatTestCount(testCaseStatus[4])}</small>
        </>
      ),
      tested: getCaseStats(4).tested,
      total: getCaseStats(4).total,
      testCount: testCaseStatus[4]?.testCount || 0,
      section: testCaseStatus[4]?.implemented ? 'implemented' : 'missing',
    },
  ];

  return <TestCasesTable rows={allRows} previewCount={4} />;
};

<ListenTestCasesTable />

## Generated Components

<div>
  <strong>Generated Components:</strong> {data.coverage.covered} of {data.coverage.total} generated (
  <strong>{data.coverage.percent}%</strong>)
</div>

<p style={{ marginTop: 8 }}>
  This section lists the generated components we build to stress the compiler. Each row is one component with a
  unique combination of decorator options (<code>target</code> Ã— <code>event</code> Ã— <code>capture</code> Ã— <code>passive</code>). If a combo fails to compile,
  we capture that as a rule in <code>data/rules.json</code>, update the list, and regenerate. The "Tested By" column reflects which
  highâ€‘level test cases cover each component.
</p>

export const ListenGeneratedComponents = () => {
  const rows = useMemo(() => {
    const items = overlay.items || [];
    const map = new Map(items.map(i => [i.optionsKey, i]));
    return (data.coveredPermutations || []).map((p, i) => {
      const [target, event, capture, passive] = p.options || [];
      const key = (p.options || []).join('|');
      const oi = map.get(key) || {};
      const caseNumbers = Array.isArray(oi.caseIds) ? [...oi.caseIds].sort((a,b) => a-b) : [];
      return {
        index: i,
        target,
        event,
        capture,
        passive,
        caseNumbers,
      };
    });
  }, []);
  
  return (
    <GeneratedComponentsTable 
      rows={rows} 
      previewCount={3}
      columns={[
        { key: 'target', label: 'target', width: '20%' },
        { key: 'event', label: 'event', width: '20%' },
        { key: 'capture', label: 'capture', width: '15%' },
        { key: 'passive', label: 'passive', width: '15%' },
        { key: 'testedBy', label: 'Tested By', width: '30%' },
      ]}
    />
  );
};

<ListenGeneratedComponents />

---

## Test Categories

### **ðŸŸ¢ Basic Target (1)** â€” 1 test case
Foundation patterns for host element listeners, covering all event types and capture/passive combinations.

### **ðŸŸ¡ Standard Patterns (2-4)** â€” 3 test cases
Common listener scenarios including global targets (window, document, body), capture phase behavior, and passive listener optimization.

---

export const ListenTODOSection = () => {
  const testCaseStatus = overlay.testCaseStatus || {};
  const missingCases = Object.entries(testCaseStatus)
    .filter(([_, tc]) => !tc.implemented)
    .map(([id, tc]) => ({ id, desc: tc.description || `Test Case #${id}` }));
  
  if (missingCases.length === 0) {
    return null;
  }
  
  return (
    <div>
      {missingCases.map(({ id, desc }) => (
        <div key={id} style={{ marginBottom: '12px' }}>
          <strong>Test Case #{id} TODO</strong>: {desc}
        </div>
      ))}
    </div>
  );
};

{(() => {
  const testCaseStatus = overlay.testCaseStatus || {};
  const missingCases = Object.entries(testCaseStatus)
    .filter(([_, tc]) => !tc.implemented);
  if (missingCases.length === 0) return null;
  return (
    <>
      <h2>ðŸ“‹ TODO - Remaining Test Cases</h2>
      <ListenTODOSection />
    </>
  );
})()}

---

## Component Grouping

Generated components are organized by target under `test/wdio/listen/components/`:

- `host/` â€” host element listeners
- `window/` â€” window global listeners
- `document/` â€” document global listeners
- `body/` â€” body element listeners
