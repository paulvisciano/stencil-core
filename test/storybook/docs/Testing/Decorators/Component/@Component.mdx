import rules from './rules.json';
import { Meta } from '@storybook/addon-docs/blocks';
import data from './coverage-data.json';
import overlay from './coverage-overlay.json';
import React, { useMemo, useState } from 'react';
import RulesAtAGlance from '../_shared/RulesAtAGlance.jsx';

<Meta title="Testing/Decorators/@Component"/>

# @Component Decorator

The `@Component` decorator is used to define a Stencil custom element, specifying its tag name, style, encapsulation, shadow DOM options, and other metadata. It is the entry point for all Stencil components and controls how they are registered and rendered.

## @Component Decorator Properties

The `@Component` decorator accepts an object with the following properties:

-   **`shadow`** (`boolean`): When `true`, the component will use native Shadow DOM encapsulation. This provides style isolation and prevents styles from leaking in or out of the component. Defaults to `false`.
-   **`scoped`** (`boolean`): When `true`, the component's styles will be scoped to the component. This is a lighter form of style encapsulation than shadow DOM and is useful when shadow DOM is not desired. Defaults to `false`.
-   **`assetsDirs`** (`string[]`): An array of strings specifying directories that contain assets, such as images or fonts, that should be copied to the output directory.
-   **`formAssociated`** (`boolean`): When `true`, the component can be associated with a form, allowing it to participate in form submission and validation.
-   **`styleUrl`** (`string`): The URL of a single stylesheet to be applied to the component. This is mutually exclusive with `styleUrls` and `styles`.
-   **`styleUrls`** (`string[]`): An array of URLs for multiple stylesheets to be applied to the component. This is mutually exclusive with `styleUrl` and `styles`.
-   **`styles`** (`string`): A string containing the CSS text to be applied directly to the component. This is mutually exclusive with `styleUrl` and `styleUrls`.

## Rules (at a glance)
<RulesAtAGlance rules={rules} sourcePath="./rules.json" />
- Component grouping: generated components are grouped by mode under `matrix/shadow`, `matrix/scoped`, and `matrix/light`. CSS paths are relative to those folders.

## Rendering Modes and Component Grouping

To simplify navigation, generated components are organized one level deep by render mode under `test/wdio/component-decorator/matrix/`:

- `shadow/` (shadow: true)
  - Uses native Shadow DOM for real DOM and CSS encapsulation
  - Slots work natively; :host and :host-context apply inside the shadow root
  - External page CSS does not leak in (CSS variables still pass through)
- `scoped/` (scoped: true, shadow: false)
  - Renders in light DOM; Stencil rewrites selectors to emulate encapsulation
  - Easier theming from outside; some global CSS may still affect layout
- `light/` (shadow: false, scoped: false)
  - Plain light DOM with no encapsulation
  - Fastest and simplest; external styles fully apply

Rule: `shadow` and `scoped` are mutually exclusive and never both `true`.

`cmp-base.tsx`, `matrix-gen.css`, and `matrix-alt.css` remain in the `matrix/` root.

## Test Case Summary

Planned WDIO tests will exercise representative permutations of the `@Component` matrix. Until then, this section serves as a placeholder for the shared summary format.

{(() => {
  const items = overlay.items || [];
  const groupCounts = new Map();
  items.forEach(i => {
    const g = i.group || 'light';
    const c = groupCounts.get(g) || { tested: 0, total: 0 };
    c.total += 1;
    if (i.tested) c.tested += 1;
    groupCounts.set(g, c);
  });

  const rows = ['shadow', 'scoped', 'light'].map(g => ({ group: g, ...(groupCounts.get(g) || { tested: 0, total: 0 }) }));

  return (
    <div style={{ maxWidth: '100%', width: '100%', background: '#fff' }}>
      <table style={{ width: '100%', borderCollapse: 'collapse' }}>
        <colgroup>
          <col style={{ width: '55%' }} />
          <col style={{ width: '20%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '15%' }} />
        </colgroup>
        <thead>
          <tr style={{ background: '#f2f2f2' }}>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Test Case</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Permutations Covered</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>Status</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Test Folder</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r, i) => (
            <tr key={i}>
              <td style={{ padding: '8px', border: '1px solid #ddd' }}>
                Render validations for {r.group} mode and asset/style combinations.
              </td>
              <td style={{ padding: '8px', border: '1px solid #ddd' }}>
                group: {r.group}<br/>
                <small>Covered: {r.tested}/{r.total}</small>
              </td>
              <td style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>
                <span style={{ color: r.tested === r.total && r.total > 0 ? 'green' : '#999' }}>{r.total > 0 ? (r.tested === r.total ? '✔' : '✗') : '—'}</span>
              </td>
              <td style={{ padding: '8px', border: '1px solid #ddd' }}>
                <code>test/wdio/component-decorator/tests</code>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
})()}

## Covered Permutations

<div>
  <strong>Permutation Coverage:</strong> {data.coverage.covered}/{data.coverage.total} permutations covered (
  <strong>{data.coverage.percent}%</strong>)
</div>

export const CoveredPermutationsTable = () => {
  const [expanded, setExpanded] = useState(false);

  const rows = useMemo(() => {
    const items = overlay.items || [];
    return (data.coveredPermutations || []).map((p, i) => {
      const optionKey = p.options.join('|');
      const oi = items.find((x) => x.optionsKey === optionKey) || {};
      return {
        index: i,
        options: p.options,
        tested: !!oi.tested,
        tests: oi.testedBy || [],
      };
    });
  }, []);

  const total = rows.length;

  const renderTable = (rowsToRender) => (
    <div style={{ maxWidth: '100%', width: '100%', background: '#fff' }}>
      <table style={{ width: '100%', borderCollapse: 'collapse', tableLayout: 'fixed' }}>
        <colgroup>
          <col style={{ width: '4%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '16%' }} />
        </colgroup>
        <thead>
          <tr>
            <th>#</th>
            <th>shadow</th>
            <th>scoped</th>
            <th>assetsDirs</th>
            <th>formAssociated</th>
            <th>styleUrl</th>
            <th>styleUrls</th>
            <th>styles</th>
            <th>Tested / Test Cases</th>
          </tr>
        </thead>
        <tbody>
          {rowsToRender.map((r) => (
            <tr key={r.index} style={{ background: r.tested ? '#fbfffb' : '#fff' }}>
              <td>{r.index + 1}</td>
              {r.options.map((opt, j) => (
                <td key={j}>{opt}</td>
              ))}
              <td>
                <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <span style={{ minWidth: 16, textAlign: 'center' }}>
                    {r.tested ? <span style={{ color: 'green' }}>✔</span> : <span style={{ color: '#999' }}>—</span>}
                  </span>
                  {r.tests.length ? (
                    <ul style={{ margin: 0, paddingLeft: 16 }}>
                      {r.tests.map((t, k) => (
                        <li key={k}>{t}</li>
                      ))}
                    </ul>
                  ) : (
                    <em>—</em>
                  )}
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );

  if (!expanded) {
    const preview = rows.slice(0, 3);
    return (
      <div style={{ position: 'relative' }}>
        {renderTable(preview)}
        {total > 3 && (
          <>
            <div
              style={{
                position: 'absolute',
                left: 0,
                right: 0,
                bottom: 40,
                height: 48,
                background: 'linear-gradient(180deg, rgba(255,255,255,0) 0%, #fff 90%)',
                pointerEvents: 'none',
              }}
            />
            <div style={{ display: 'flex', justifyContent: 'center', marginTop: -8 }}>
              <button
                onClick={() => setExpanded(true)}
                style={{
                  padding: '6px 12px',
                  border: '1px solid #ddd',
                  background: '#f8f8f8',
                  borderRadius: 4,
                  cursor: 'pointer',
                  fontSize: 12,
                }}
                aria-label={`Show all ${total} permutations`}
              >
                Show all {total}
              </button>
            </div>
          </>
        )}
      </div>
    );
  }

  return (
    <div>
      <div style={{ display: 'flex', justifyContent: 'flex-end', marginBottom: 8 }}>
        <button
          onClick={() => setExpanded(false)}
          style={{
            padding: '6px 12px',
            border: '1px solid #ddd',
            background: '#f8f8f8',
            borderRadius: 4,
            cursor: 'pointer',
            fontSize: 12,
          }}
          aria-label="Collapse permutations table"
        >
          Collapse table
        </button>
      </div>
      {renderTable(rows)}
    </div>
  );
};

<CoveredPermutationsTable />
