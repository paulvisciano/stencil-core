import rules from './rules.json';
import { Meta } from '@storybook/addon-docs/blocks';
import data from './coverage-data.json';
import overlay from './coverage-overlay.json';

<Meta title="Testing/Decorators/@Component"/>

# @Component Testing Matrix

The `@Component` decorator is used to define a Stencil custom element, specifying its tag name, style, encapsulation, shadow DOM options, and other metadata. It is the entry point for all Stencil components and controls how they are registered and rendered.

## Rules (at a glance)
- Styles are mutually exclusive: use exactly one of {rules.exclusiveGroups.find(g => g.name === 'styles').members.join(' | ')}.
- Encapsulation flags are mutually exclusive: {rules.exclusiveGroups.find(g => g.name === 'encapsulation').members.join(' and ')} cannot both be `true`.
- Render modes: {rules.modes.map(m => m.name).join(', ')}.
- Matrix conventions: generated examples are grouped by render mode under `matrix/shadow`, `matrix/scoped`, and `matrix/light`; CSS asset paths are parent‑relative from grouped subfolders.

## Component Properties

The `@Component` decorator accepts an object with the following properties:

-   **`shadow`** (`boolean`): When `true`, the component will use native Shadow DOM encapsulation. This provides style isolation and prevents styles from leaking in or out of the component. Defaults to `false`.
-   **`scoped`** (`boolean`): When `true`, the component's styles will be scoped to the component. This is a lighter form of style encapsulation than shadow DOM and is useful when shadow DOM is not desired. Defaults to `false`.
-   **`assetsDirs`** (`string[]`): An array of strings specifying directories that contain assets, such as images or fonts, that should be copied to the output directory.
-   **`formAssociated`** (`boolean`): When `true`, the component can be associated with a form, allowing it to participate in form submission and validation.
-   **`styleUrl`** (`string`): The URL of a single stylesheet to be applied to the component. This is mutually exclusive with `styleUrls` and `styles`.
-   **`styleUrls`** (`string[]`): An array of URLs for multiple stylesheets to be applied to the component. This is mutually exclusive with `styleUrl` and `styles`.
-   **`styles`** (`string`): A string containing the CSS text to be applied directly to the component. This is mutually exclusive with `styleUrl` and `styleUrls`.

## Rendering Modes and Matrix Grouping

To simplify navigation of the generated matrix, components are organized one level deep by render mode under `test/wdio/component-decorator/matrix/`:

- `shadow/` (shadow: true)
  - Uses native Shadow DOM for real DOM and CSS encapsulation
  - Slots work natively; :host and :host-context apply inside the shadow root
  - External page CSS does not leak in (CSS variables still pass through)
- `scoped/` (scoped: true, shadow: false)
  - Renders in light DOM; Stencil rewrites selectors to emulate encapsulation
  - Easier theming from outside; some global CSS may still affect layout
- `light/` (shadow: false, scoped: false)
  - Plain light DOM with no encapsulation
  - Fastest and simplest; external styles fully apply

Rule: `shadow` and `scoped` are mutually exclusive and never both `true`.

`cmp-base.tsx`, `matrix-gen.css`, and `matrix-alt.css` remain in the `matrix/` root.

## Test Case Summary

Planned WDIO tests will exercise representative permutations of the `@Component` matrix. Until then, this section serves as a placeholder for the shared summary format.

{(() => {
  const items = overlay.items || [];
  const groupCounts = new Map();
  items.forEach(i => {
    const g = i.group || 'light';
    const c = groupCounts.get(g) || { tested: 0, total: 0 };
    c.total += 1;
    if (i.tested) c.tested += 1;
    groupCounts.set(g, c);
  });

  const rows = ['shadow', 'scoped', 'light'].map(g => ({ group: g, ...(groupCounts.get(g) || { tested: 0, total: 0 }) }));

  return (
    <div style={{ maxWidth: '100%', width: '100%', background: '#fff' }}>
      <table style={{ width: '100%', borderCollapse: 'collapse' }}>
        <colgroup>
          <col style={{ width: '55%' }} />
          <col style={{ width: '20%' }} />
          <col style={{ width: '10%' }} />
          <col style={{ width: '15%' }} />
        </colgroup>
        <thead>
          <tr style={{ background: '#f2f2f2' }}>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Test Case</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Permutations Covered</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>Status</th>
            <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Test Folder</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r, i) => (
            <tr key={i}>
              <td style={{ padding: '8px', border: '1px solid #ddd' }}>
                Render validations for {r.group} mode and asset/style combinations.
              </td>
              <td style={{ padding: '8px', border: '1px solid #ddd' }}>
                group: {r.group}<br/>
                <small>Covered: {r.tested}/{r.total}</small>
              </td>
              <td style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>
                <span style={{ color: r.tested === r.total && r.total > 0 ? 'green' : '#999' }}>{r.total > 0 ? (r.tested === r.total ? '✔' : '✗') : '—'}</span>
              </td>
              <td style={{ padding: '8px', border: '1px solid #ddd' }}>
                <code>test/wdio/component-decorator/tests</code>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
})()}

## Covered Permutations

<div>
  <strong>Permutation Coverage:</strong> {data.coverage.covered}/{data.coverage.total} permutations covered (
  <strong>{data.coverage.percent}%</strong>)
</div>

<div style={{ maxWidth: '100%', width: '100%', background: '#fff' }}>
  <table style={{ width: '100%', borderCollapse: 'collapse', tableLayout: 'fixed' }}>
    <colgroup>
      <col style={{ width: '4%' }} />
      <col style={{ width: '10%' }} />
      <col style={{ width: '10%' }} />
      <col style={{ width: '10%' }} />
      <col style={{ width: '10%' }} />
      <col style={{ width: '10%' }} />
      <col style={{ width: '10%' }} />
      <col style={{ width: '10%' }} />
      <col style={{ width: '16%' }} />
    </colgroup>
    <thead>
      <tr>
        <th>#</th>
        <th>shadow</th>
        <th>scoped</th>
        <th>assetsDirs</th>
        <th>formAssociated</th>
        <th>styleUrl</th>
        <th>styleUrls</th>
        <th>styles</th>
        <th>Tested / Test Cases</th>
      </tr>
    </thead>
    <tbody>
      {data.coveredPermutations.map((p, i) => {
        const optionKey = p.options.join('|');
        const oi = (overlay.items || []).find(x => x.optionsKey === optionKey);
        const tested = oi?.tested;
        const tests = oi?.testedBy || [];
        return (
          <tr key={i} style={{ background: tested ? '#fbfffb' : '#fff' }}>
            <td>{i + 1}</td>
            {p.options.map((opt, j) => (
              <td key={j}>{opt}</td>
            ))}
            <td>
              <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                <span style={{ minWidth: 16, textAlign: 'center' }}>{tested ? <span style={{ color: 'green' }}>✔</span> : <span style={{ color: '#999' }}>—</span>}</span>
                {tests.length ? (
                  <ul style={{ margin: 0, paddingLeft: 16 }}>
                    {tests.map((t, k) => (
                      <li key={k}>{t}</li>
                    ))}
                  </ul>
                ) : (
                  <em>—</em>
                )}
              </div>
            </td>
          </tr>
        );
      })}
    </tbody>
  </table>
</div>
