import data from './method-coverage-data.json';

# @Method Testing Matrix

The `@Method` decorator is used to expose a method on a component's public API. This matrix tracks the test coverage for different method signatures.

## Method Characteristics

The `@Method` decorator itself does not take any arguments, but the signature of the method it decorates has several important characteristics that determine its behavior.

- **`async`**: An `async` method returns a `Promise`. When calling an `async` method from a test, you must use `await` to get the result and ensure the test waits for the method to complete.

- **Arguments**: Methods can accept arguments, allowing you to pass data into the component. Tests should cover cases with and without arguments, as well as different types of arguments.

- **Return Value**: Methods can return values, which is how a component can expose data or state to its consumers. Tests should verify that the correct value is returned, including for `async` methods where the value will be wrapped in a `Promise`.

## Covered Permutations

<div>
  <strong>Permutation Coverage:</strong> {data.coverage.covered}/{data.coverage.total} permutations covered (
  <strong>{data.coverage.percent}%</strong>)
</div>

<div style={{ maxWidth: '100%', width: '100%', background: '#fff' }}>
  <table style={{ width: '100%', borderCollapse: 'collapse', tableLayout: 'fixed' }}>
    <colgroup>
      <col style={{ width: '25%' }} />
      <col style={{ width: '25%' }} />
      <col style={{ width: '25%' }} />
      <col style={{ width: '25%' }} />
    </colgroup>
    <thead>
      <tr>
        <th>Async</th>
        <th>Has Arguments</th>
        <th>Has Return Value</th>
        <th>Number of Occurrences</th>
      </tr>
    </thead>
    <tbody>
      {data.coveredPermutations.map((p, i) => (
        <tr key={i}>
          {p.options.map((opt, j) => (
            <td key={j}>{opt}</td>
          ))}
          <td>{p.count}</td>
        </tr>
      ))}
    </tbody>
  </table>
</div>

## Test Case Summary

The following table summarizes the actual component-level WDIO test cases for the `@Method` decorator. All async permutations (args/no args, return/no return) are covered by the same test pattern:

<div style={{ maxWidth: '100%', width: '100%', background: '#fff' }}>
  <table style={{ width: '100%', borderCollapse: 'collapse' }}>
    <colgroup>
      <col style={{ width: '50%' }} />
      <col style={{ width: '30%' }} />
      <col style={{ width: '20%' }} />
    </colgroup>
    <thead>
      <tr style={{ background: '#f2f2f2' }}>
        <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Test Case</th>
        <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>Permutations Covered</th>
        <th style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>Status</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style={{ padding: '8px', border: '1px solid #ddd' }}>
          Clicking the component's button calls the async <code>@Method</code>, which updates a <code>@State</code> property and reflects the change in the DOM.
        </td>
        <td style={{ padding: '8px', border: '1px solid #ddd' }}>
          async: true, args: true/false, return: true/false
        </td>
        <td style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>
          <span style={{ color: 'green' }}>✔</span>
        </td>
      </tr>
      <tr style={{ background: '#f9f9f9' }}>
        <td style={{ padding: '8px', border: '1px solid #ddd' }}>
          Programmatically call the async <code>@Method</code> from test code and verify state/DOM updates.
        </td>
        <td style={{ padding: '8px', border: '1px solid #ddd' }}>
          async: true, args: true/false, return: true/false
        </td>
        <td style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'center' }}>
          <span style={{ color: 'red' }}>✖</span>
        </td>
      </tr>
    </tbody>
  </table>
</div>

