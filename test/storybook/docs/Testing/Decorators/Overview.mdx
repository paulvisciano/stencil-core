import componentData from './Component/coverage-data.json';
import propData from './Prop/coverage-data.json';
import stateData from './State/coverage-data.json';
import eventData from './event-coverage-data.json';
import listenData from './listen-coverage-data.json';
import methodData from './method-coverage-data.json';

# Decorator Testing Overview

This section tracks test coverage for all Stencil decorators. Each decorator has its own matrix and coverage notes. Use this as a reference for contributors and maintainers.

## What Are Decorators in Stencil?
Stencil decorators are special TypeScript annotations that add metadata and behavior to component classes, properties, methods, and events. They enable features like reactive state, property reflection, and event emission. Decorators are a core part of Stencil's API and are used to define how components interact with the DOM and with each other.

### Example Stencil Component Using Decorators
```tsx
import { Component, Prop, State, Event, EventEmitter, Method, Listen } from '@stencil/core';

@Component({
  tag: 'example-cmp',
})
export class ExampleCmp {
  @Prop({ reflect: true }) label: string;
  @State() count: number = 0;
  @Event() valueChanged: EventEmitter<number>;

  @Method()
  async increment() {
    this.count++;
    this.valueChanged.emit(this.count);
  }

  @Listen('click', { target: 'window' })
  handleWindowClick() {
    // handle global click
  }

  render() {
    return <button onClick={() => this.increment()}>{this.label}: {this.count}</button>;
  }
}
```

## Decorators

Below are all the decorators provided by Stencil. Each decorator has a dedicated page that includes a detailed test coverage matrix, along with a description and usage examples. Click the name of the decorator to view its testing matrix:

- [`@Component`](?path=/docs/testing-decorators-component): Defines a custom element and its metadata, such as tag name, style, encapsulation, and shadow DOM options.
  ```tsx
  @Component({ tag: 'example-cmp' })
  export class ExampleCmp { /* ... */ }
  ```

- [`@Prop`](?path=/docs/testing-decorators-prop): Exposes a property to consumers and can reflect it to an attribute.
  ```tsx
  @Prop({ reflect: true }) label: string;
  ```

- [`@State`](?path=/docs/testing-decorators-state): Creates internal reactive state.
  ```tsx
  @State() count: number = 0;
  ```

- [`@Event`](?path=/docs/testing-decorators-event): Allows the component to emit custom events.
  ```tsx
  @Event() valueChanged: EventEmitter<number>;
  ```

- [`@Method`](?path=/docs/testing-decorators-method): Exposes public methods to consumers.
  ```tsx
  @Method()
  async increment() { /* ... */ }
  ```

- [`@Listen`](?path=/docs/testing-decorators-listen): Attaches event listeners to the host, window, or document.
  ```tsx
  @Listen('click', { target: 'window' })
  handleWindowClick() { /* ... */ }
  ```

## Project Phases

### Phase 1. Documentation and Component Generation

- Document all properties of each decorator.
- Define a permutation matrix for the Decorator based on the properties
- Create a script to generate components based off of the permutations matrix
- Verify the matrix and `compile all generated components` to discover `actual compiler rules` (e.g., mutually-exclusive options).
- Update `rules.json` with discovered rules and adjust the matrix; regenerate until all components compile.
- Prevent drift: docs render rules from `rules.json` using `RulesAtAGlance`, and a verify script checks accuracy.
- Doc layout convention per decorator:
  1) Decorator Properties
  2) Rules (at a glance)
  3) Generated Components
  4) Component Grouping
  5) Test Cases

<div role="note" aria-label="Phase 1 Goal"
  style={{ border: '1px solid #e0e0e0', background: '#fffbe6', padding: 12, borderRadius: 6, margin: '12px 0' }}>
  <div style={{ fontWeight: 600, marginBottom: 6 }}>Phase 1 Goal</div>
  <ul style={{ margin: 0, paddingLeft: 18 }}>
    <li>Stress-test the compiler by generating a broad set of components (unique option combinations).</li>
    <li>Discover the true, compiler‑enforced rules and record them in <code>rules.json</code>.</li>
    <li>Regenerate until <strong>100%</strong> of generated components compile cleanly.</li>
  </ul>
</div>

### Phase 2. Behavioral Tests for Generated Components

- Purpose: verify that compiled components from Phase 1 behave as expected at runtime.
- Reuse existing WDIO tests as templates; study each test’s use case and intent.
- Propagate each applicable test across all generated components that match the scenario (skip when not applicable).
- Record results in each decorator’s `coverage-overlay.json` (`tested`, `testedBy`) so the “Tested / Test Cases” column reflects reality.
- Prefer tags/metadata to express applicability (e.g., by mode/options) so propagation is automated and repeatable.
- Report progress in docs; do not change compiler rules in Phase 2 unless tests uncover spec gaps.

<div role="note" aria-label="Phase 2 Goal"
  style={{ border: '1px solid #e0e0e0', background: '#e6f7ff', padding: 12, borderRadius: 6, margin: '12px 0' }}>
  <div style={{ fontWeight: 600, marginBottom: 6 }}>Phase 2 Goal</div>
  <ul style={{ margin: 0, paddingLeft: 18 }}>
    <li>Give confidence that the compiled components from Phase 1 (Web Components) also work as expected at runtime</li>
    <li>Systematically apply relevant WDIO tests to every applicable generated component.</li>
    <li>Track tested status in overlay and surface it in the docs.</li>
  </ul>
</div>

## Coverage Summary

<div style={{ maxWidth: '100%', width: '100%', background: '#fff' }}>
  <table style={{ width: '100%', borderCollapse: 'collapse', tableLayout: 'fixed' }}>
    <colgroup>
      <col style={{ width: '50%' }} />
      <col style={{ width: '50%' }} />
    </colgroup>
    <thead>
      <tr>
        <th>Decorator</th>
        <th style={{ textAlign: 'center' }}>Coverage Percentage</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>@Component</td>
        <td style={{ textAlign: 'center' }}>{componentData.coverage.percent}%</td>
      </tr>
      <tr>
        <td>@Prop</td>
        <td style={{ textAlign: 'center' }}>{propData.coverage.percent}%</td>
      </tr>
      <tr>
        <td>@State</td>
        <td style={{ textAlign: 'center' }}>{stateData.coverage.percent}%</td>
      </tr>
      <tr>
        <td>@Event</td>
        <td style={{ textAlign: 'center' }}>{eventData.coverage.percent}%</td>
      </tr>
      <tr>
        <td>@Listen</td>
        <td style={{ textAlign: 'center' }}>{listenData.coverage.percent}%</td>
      </tr>
      <tr>
        <td>@Method</td>
        <td style={{ textAlign: 'center' }}>{methodData.coverage.percent}%</td>
      </tr>
    </tbody>
  </table>
</div>