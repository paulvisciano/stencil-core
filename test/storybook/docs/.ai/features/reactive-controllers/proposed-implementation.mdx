# Controller Decorator — Proposed Implementation

References
- GitHub issue: https://github.com/stenciljs/core/issues/3162
- Repo testing conventions and keywords: see `.ai/testing/AGENT_KEYWORDS.md`
- Lit reference (non-goal for alignment, useful background): https://github.com/lit/lit/blob/main/packages/reactive-element/src/reactive-controller.ts
- Sample: https://gist.github.com/WickyNilliams/79ee85ea370506ac6b16de1920f48e5e

Summary
- Tags: [EFFORT: XL] [RISK: Medium-High] [CONFIDENCE: Medium] (per `.ai/testing/AGENT_KEYWORDS.md`)
- Goal: Provide a first-class mechanism to attach reusable, lifecycle-aware controller objects to Stencil components.
- Priority decision: Use a new `@Controller` decorator as the primary approach (compiler-first), per Christian’s guidance. Lit alignment/interop is a non-goal for the initial phase.
- MVP: Implement `@Controller` (compiler transform) that auto-registers controller instances on the host. Back it with minimal runtime host support that invokes controller hooks at the correct lifecycle points.

Terminology
- Controller (type `ReactiveController`): plain class with optional lifecycle methods: `hostConnected`, `hostDisconnected`, `hostUpdate`, `hostUpdated`. May call `host.requestUpdate()`.
- ReactiveControllerHost: component instance API used by controllers: `addController`, `removeController`, `requestUpdate()`.

API Surface (Phase 1: decorator-first)
- Decorator
  - `@Controller()` on a class field marks the field as a controller instance to auto-register with the host.
  - Example:

```tsx
class MyCmp {
  @Controller() mouse = new MouseController(this);
}
```

  - Phase 1 keeps the decorator simple (no options). Controllers persist for the lifetime of the component instance; they are registered once (constructor) and receive lifecycle callbacks on connect/disconnect. No auto-removal is injected.

- Under-the-hood host API (runtime backing, available but not the user-facing entrypoint):

```ts
interface ReactiveController {
  hostConnected?(): void;
  hostDisconnected?(): void;
  hostUpdate?(): void | Promise<void>;
  hostUpdated?(): void;
}
interface ReactiveControllerHost {
  addController(controller: ReactiveController): void;
  removeController(controller: ReactiveController): void;
  requestUpdate(): void;
}
```

  - Users can still manually register controllers if needed, but the recommended path is `@Controller`.

Design Options
- Option A (recommended Phase 1): Decorator-first. Implement `@Controller` via compiler transform that injects `this.addController(this.<field>)` in the component constructor. Minimal runtime adds the host API and lifecycle hook dispatch.
- Option B (fallback/advanced): Manual registration without the decorator using the same runtime host API. Documented as advanced usage; not the focus of Phase 1 docs.

Recommended Phasing
1) Phase 1: Compiler + runtime
   - Implement `@Controller` decorator transform.
   - Implement runtime host support and lifecycle hook dispatch (connected/disconnected/update/updated).
   - Types for controllers/host in public runtime declarations.
   - Tests for both compiler transform and runtime behavior.
2) Phase 2: Enhancements (optional)
   - Decorator options (e.g., `order`, `lifecycles`), and/or a factory signature.
   - Interop polish and documentation for cross-framework controllers where it makes sense.

Runtime Changes (backing for decorator)
Invoke controller hooks at the following points:
- hostConnected: in custom element `connectedCallback`, after Stencil’s internal connected wiring, before scheduling initial update.
- hostDisconnected: in `disconnectedCallback` after Stencil tear-down of listeners.
- hostUpdate: immediately before `componentWillRender` runs in update scheduling.
- hostUpdated: immediately after postUpdate (after render + didUpdate/didLoad paths).

Implementation details
- Maintain a `Set<ReactiveController>` per instance, plus `addController`/`removeController` and `requestUpdate` methods. `requestUpdate` calls existing `forceUpdate(this)`.
- Iterate hooks with try/catch around each controller to avoid failing the host lifecycle.

Files to modify — Runtime/Types (Phase 1)
- Public types:
  - `src/declarations/stencil-public-runtime.ts`
    - Add `ReactiveController` and `ReactiveControllerHost` interfaces; export them.
    - Ensure host instances expose `requestUpdate(): void` typing.

- Runtime: dist-custom-elements path
  - `src/runtime/bootstrap-custom-element.ts`
    - When augmenting the prototype via `Object.assign(Cstr.prototype, { ... })`, add:
      - `controllers: new Set()`
      - `addController(controller)`, `removeController(controller)`
      - `requestUpdate() { forceUpdate(this) }`
      - In `connectedCallback()`: after internal `connectedCallback(this)` plumbing, iterate `controllers` and call `hostConnected?.()`.
      - In `disconnectedCallback()`: iterate `controllers` and call `hostDisconnected?.()`.

- Runtime: lazy path
  - `src/runtime/bootstrap-lazy.ts`
    - Mirror the prototype augmentation (controllers Set, add/remove, requestUpdate) and the connected/disconnected hook invocation.

- Runtime: lifecycle scheduler
  - `src/runtime/update-component.ts`
    - Before `componentWillRender`, iterate controllers and call `hostUpdate?.()`. If any return a Promise, await them within the same microtask scheduling group.
    - After the post-update path (`componentDidUpdate/DidLoad`), iterate controllers and call `hostUpdated?.()`.

Compiler Changes (Phase 1: `@Controller`)
- Decorator behavior
  - Applied to a property declaration that instantiates a controller: `@Controller() mouse = new MouseController(this)`.
  - Transform rules:
    - Remove the decorator syntax on the field.
    - Ensure a class constructor exists; if not, synthesize one that calls `super()` when needed.
    - Inject at the end of the constructor body: `this.addController(this.<fieldName>);`
    - Do not inject removal code; controllers persist with the instance.
  - Phase 2 (optional): support a factory signature such as `@Controller(MouseController) mouse!: MouseController` which would generate `this.mouse = new MouseController(this); this.addController(this.mouse);` if no initializer is present.

- Files to modify
  - `src/compiler/transformers/decorators-to-static/decorators-constants.ts`
    - Add `'Controller'` to the recognized member decorators.
  - `src/compiler/transformers/decorators-to-static/controller-decorator.ts` (new)
    - Parse `@Controller(...)` on `PropertyDeclaration`s.
    - Collect targets and, via `transform-utils.updateConstructor`, inject `this.addController(this.<field>);` after the constructor’s super call (if present).
    - Ensure the original decorator is stripped from the AST output.
  - `src/compiler/transformers/decorators-to-static/convert-decorators.ts`
    - Wire the new controller decorator handler, similar to existing member decorators (no static metadata required for runtime).
  - `src/compiler/transformers/transform-utils.ts`
    - Reuse existing constructor update utilities. No structural changes anticipated.
  - `src/declarations/stencil-public-compiler.ts`
    - Document the new decorator in comments/types where applicable.

Lifecycle Ordering and Semantics (fixed in Phase 1)
- Registration time: constructor (via injected `addController`).
- Connected/Disconnected: controller hooks are called after internal connect plumbing and before first update; and after internal disconnect tear-down, respectively.
- Update Cycle: `hostUpdate` is called before `componentWillRender`; `hostUpdated` is called after post-update (`didUpdate/didLoad`).
- Error handling: use a `safeCall`-style try/catch for each controller hook. Errors are logged but do not break the host lifecycle.

DX Examples
- With `@Controller` (Phase 1)

```tsx
class MyCmp {
  @Controller() mouse = new MouseController(this);
  render() { /* ... */ }
}
```

- Advanced/manual (fallback)

```ts
class MyCmp implements ReactiveControllerHost {
  mouse = new MouseController(this);
  constructor() {
    super?.();
    this.addController(this.mouse);
  }
}
```

Compatibility and Interop
- Non-goal for Phase 1. Controllers written for other frameworks may work if they only rely on the minimal host API, but this is not a target for the initial release.

Performance
- Controller sets are typically small. Hook iteration adds O(n controllers) overhead per lifecycle and is comparable to watcher/event handling.
- Only additional microtasks arise when controllers return Promises from `hostUpdate`; these are batched alongside existing scheduler microtasks.

Risk and Complexity vs Existing Decorators
- Summary
  - Type: instance member decorator on a field, transform-only injection (no static metadata), with small runtime backing (host API + lifecycle dispatch).
  - Relative complexity: low-to-medium. Considerably simpler than `@Prop`/`@State`/`@Listen`; similar or simpler than `@Method`/`@Watch` in transform shape.

- Transform complexity
  - Remove decorator, ensure constructor exists, preserve `super()`, and inject `this.addController(this.<field>);` after field initializers. Handle multiple decorated fields once per field.
  - Edge cases to guard:
    - No constructor (synthesize one), inheritance (place after `super()`), field without initializer (unsupported in Phase 1; factory form is Phase 2), static fields (reject), accessors (reject).
    - Avoid double-evaluating initializers; do not move the initializer, only inject an add-call.
  - Source maps and formatting parity follow existing decorator tests under `Testing/Decorators`.

- Runtime complexity
  - Add per-instance `controllers` Set, `addController`/`removeController`, `requestUpdate`, and four hook dispatch points (connect/disconnect/update/updated) in both lazy and dist-custom-elements paths.
  - Parity requirements are narrower than event wiring for `@Listen` and significantly simpler than the reactivity/runtime proxies for `@Prop`/`@State`.

- Compatibility and naming risks
  - Prototype surface additions (`controllers`, `addController`, `removeController`, `requestUpdate`) may collide with user-defined members. Mitigations: define as non-enumerable, document names, and validate no internal collisions. Consider feature flagging in canaries if needed.
  - Decorator semantics: Stencil uses legacy TS decorators. Clearly scope `@Controller` to the legacy pipeline; defer Stage 3 semantics until broader decorator migration.

- Output targets and lifecycle risks
  - Ensure identical behavior in `bootstrap-custom-element` and `bootstrap-lazy`; hydrate/server paths remain no-ops for hooks.
  - Ordering with component lifecycle and watchers must remain stable (fixed ordering defined above). Promise-returning `hostUpdate` must integrate with the existing scheduler without deadlocks.

- Comparative complexity highlights (approximate)
  - `@Component` (class): high — component registration, metadata, styles, encapsulation.
  - `@Prop` (member): very high — metadata, attr/reflect, runtime accessors, re-render triggers, validation.
  - `@State` (member): high — internal reactivity, invalidation, render scheduling.
  - `@Event` (member): medium-high — emitter creation, metadata, typing.
  - `@Listen` (member): medium-high — metadata, target resolution, options (capture/passive), attach/detach.
  - `@Watch` (member): medium — metadata, watcher scheduling.
  - `@Method` (member): medium — prototype exposure, async wrapping.
  - `@Element` (member): low — host reference injection.
  - `@Controller` (member): low-to-medium — constructor injection + small runtime hooks; no metadata, no attribute/DOM wiring.

- Testing scope
  - Narrower than `@Prop`/`@Listen`: focus on transform injection correctness and lifecycle dispatch order. Reuse `.ai/testing/AGENT_KEYWORDS.md` conventions for RISK/COMPLEXITY/SCOPE tags in test descriptions.

Testing Strategy
- Compiler (Phase 1):
  - Verify that `@Controller()` on a field removes the decorator and injects `this.addController(this.<field>)` into the constructor (creating one if absent, preserving `super()`).
  - Verify no duplicate injections across re-builds and that multiple decorated fields generate one add per field.
  - Verify optional factory path in Phase 2 when implemented.
- Runtime:
  - Verify controllers receive `hostConnected`/`hostDisconnected` at expected times.
  - Verify `hostUpdate` is called before render and can delay render when returning a Promise.
  - Verify `hostUpdated` is called after post-update.
  - Verify `requestUpdate` schedules an update.

Docs and Examples
- Add a Controller decorator guide focused on the `@Controller` decorator. Include composition examples (e.g., `MouseController`, `ResizeController`).
- Reference `.ai/testing/AGENT_KEYWORDS.md` to keep terminology consistent (MVP, scope, acceptance criteria, etc.).

Scope Answer (updated)
- Runtime: add `ReactiveControllerHost` backing API and invoke controller hooks across both lazy and dist-custom-elements output targets; integrate with the update scheduler.
- Types: expose public interfaces for controller/host and `requestUpdate` typing.
- Compiler: ship `@Controller` field decoration to auto-register controllers (no ordering/lifecycle-filter options in Phase 1).
- Tests: compiler transform tests + runtime unit tests.
- Docs: developer guide and examples.

Estimate Answer (XL sizing with onboarding)
- Sizing and tags (see `.ai/testing/AGENT_KEYWORDS.md`)
  - [EFFORT: XL] per Christian’s assessment; compiler + runtime cross-cutting change with wide blast radius.
  - [RISK: Medium-High] ordering, scheduler integration, output-target parity, decorator transform edge cases.
  - [CONFIDENCE: Medium] mitigated by stronger tests and community review.

- Assumptions
  - New dev (Jacob) requires 1–2 weeks onboarding; you harden tests in parallel; community (e.g., jjenks) supports onboarding/review. Consolidated context (this doc + .ai + Testing/Decorators) provided up front.
  - Conservative scheduling with explicit contingency time and review cycles.

- Milestone timeline (calendar weeks)
  - Weeks 0–2: Onboarding + environment + codebase tour; study `.ai` + `docs/Testing/Decorators`; align on scope/acceptance; expand guardrail tests. Deliverables: RFC sign-off; failing tests codifying requirements.
  - Weeks 3–4: Compiler transform skeleton for `@Controller` (strip decorator, ensure constructor, inject add call). Core transform tests passing. Start runtime host API stubs.
  - Weeks 5–6: Runtime hook dispatch in lazy and dist-custom-elements; lifecycle tests green; constructor synthesis and `super()` preservation nailed down. Initial docs/examples.
  - Week 7: Edge cases (multiple fields, inheritance nuances, unsupported initializer behavior); CI green across output targets.
  - Week 8: Community review/feedback pass; integrate fixes. Optional canary/feature-flag rollout.
  - Weeks 9–10 (contingency buffer): Performance/regression fixes, flaky test stabilization, final documentation polish.

- Phase 1 (decorator + runtime + types + tests + docs)
  - Typical calendar: 8–10 weeks (range 7–12) reflecting XL sizing and onboarding.
  - Note: If we also inject lifecycle calls directly into component methods (Christian’s variant) in addition to runtime host hooks, allocate +1–2 weeks for compiler work and tests (within or on top of the buffer).

- Phase 2 (optional enhancements)
  - Calendar: 2–4 weeks
    - Decorator options/factory: 1–1.5 weeks
    - Interop polish/docs (if pursued): 0.5–1 week
    - Review/iteration: 0.5–1.5 weeks

Open Questions
- Do we want to support a factory signature in the initial decorator, or keep Phase 1 strictly to field-initializer + auto-register?
- Is `removeController` expected to be used by apps, or should we keep it undocumented initially and revisit after feedback?
- Any output-target-specific concerns (e.g., hydration server) that need explicit test coverage beyond no-op hooks?

Risks
- Hook invocation order expectations from other ecosystems; we document Stencil’s fixed ordering.
- Promise-based `hostUpdate` must integrate cleanly with the existing scheduler to avoid deadlocks.

Acceptance Criteria
- A Stencil component with a decorated controller field receives all four hooks at the correct times, and controllers can call `host.requestUpdate` to trigger renders.
- No breaking changes; existing apps unaffected when not using controllers.
- Compiler transform is robust: handles missing constructor, preserves `super()`, and removes the decorator syntax.

Addendum: Future Interop
- As a follow-up, evaluate a small compatibility layer for controllers authored against Lit’s typings where beneficial, without committing to full alignment. Document any caveats separately.
