/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
export namespace Components {
    interface CompositionCheckboxGroup {
    }
    interface CompositionRadioGroup {
    }
    /**
     * Main component that demonstrates composition-based scaling
     * with 3 components and 2 controllers (ValidationController and FocusController)
     */
    interface CompositionScalingDemo {
    }
    interface CompositionTextInput {
    }
    interface ExtendedCmp {
        "method1": () => Promise<void>;
        "method2": () => Promise<void>;
        /**
          * @default 'ExtendedCmp text'
         */
        "prop1": string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2": string;
    }
    interface ExtendedCmpCmp {
        "method1": () => Promise<void>;
        "method2": () => Promise<void>;
        /**
          * @default 'ExtendedCmp text'
         */
        "prop1": string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2": string;
    }
    interface ExtendsAbstract {
        "method1": () => Promise<void>;
        "method2": () => Promise<void>;
        /**
          * @default 'default text'
         */
        "prop1": string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2": string;
    }
    interface ExtendsCmpCmp {
        "method1": () => Promise<void>;
        "method2": () => Promise<void>;
        /**
          * @default 'default text'
         */
        "prop1": string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2": string;
    }
    interface ExtendsControllerUpdates {
    }
    interface ExtendsDirectState {
    }
    interface ExtendsExternal {
        "method1": () => Promise<void>;
        "method2": () => Promise<void>;
        /**
          * @default 'default text'
         */
        "prop1": string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2": string;
    }
    interface ExtendsLifecycleBasic {
    }
    interface ExtendsLifecycleMultilevel {
    }
    interface ExtendsMethods {
        /**
          * Base method that can be called by child components
         */
        "baseMethod": () => Promise<string>;
        /**
          * Child-specific method that uses parent's protected helper
         */
        "childMethod": () => Promise<string>;
        /**
          * Method that composes parent and child behavior
         */
        "composedMethod": () => Promise<string>;
        /**
          * Method to get the call log for testing
         */
        "getCallLog": () => Promise<string[]>;
        /**
          * Method to get internal value for testing
         */
        "getInternalValue": () => Promise<string>;
        /**
          * Override parent method with super() call
         */
        "overridableMethod": () => Promise<string>;
        /**
          * Method to reset state for testing
         */
        "reset": () => Promise<void>;
        /**
          * Method to trigger display update from test
         */
        "updateDisplay": (value: string) => Promise<void>;
    }
    interface ExtendsMixinCmp {
        "method1": () => Promise<void>;
        "method2": () => Promise<void>;
        "method3": () => Promise<void>;
        /**
          * @default 'default text'
         */
        "prop1": string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2": string;
        /**
          * @default 'mixin b text'
         */
        "prop3": string;
    }
    /**
     * Test Case #3: Property & State Inheritance Basics
     * This component extends PropsStateBase to test:
     * -
     * @Prop inheritance from base class
     * -
     * @State inheritance from base class
     * - Additional
     * @Prop and
     * @State without conflicts
     * - Property reactivity (inherited props/state trigger re-renders)
     */
    interface ExtendsPropsState {
        /**
          * @default 0
         */
        "baseCount": number;
        /**
          * @default 'base prop value'
         */
        "baseProp": string;
        /**
          * @default 'component prop value'
         */
        "componentProp": string;
        "incrementBaseCount": () => Promise<void>;
        "toggleBaseEnabled": () => Promise<void>;
        "updateBaseState": (value: string) => Promise<void>;
        "updateComponentState": (value: string) => Promise<void>;
    }
    /**
     * Test Case #5: Render Method Inheritance
     * This component extends RenderBase to test:
     * - Render Inheritance: Component render() method calls super.render() to include parent template
     * - Template Composition: Component composes parent template with additional content and structure
     * - Slot Integration: Parent template slots work correctly when inherited and extended
     * - CSS Class Inheritance: CSS classes from parent template maintained in component extension
     */
    interface ExtendsRender {
    }
    interface ExtendsViaHostCmp {
    }
    interface InheritanceCheckboxGroup {
    }
    interface InheritanceRadioGroup {
    }
    /**
     * Main component that demonstrates inheritance-based scaling
     * with 3 components and 2 controllers (ValidationController and FocusController)
     */
    interface InheritanceScalingDemo {
    }
    interface InheritanceTextInput {
    }
    interface TsTargetProps {
        /**
          * @default 'basicProp'
         */
        "basicProp": string;
        "decoratedGetterSetterProp": number;
        /**
          * @default -10
         */
        "decoratedProp": number;
        "dynamicLifecycle": string[];
    }
}
export interface CompositionCheckboxGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCompositionCheckboxGroupElement;
}
export interface CompositionRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLCompositionRadioGroupElement;
}
export interface InheritanceCheckboxGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInheritanceCheckboxGroupElement;
}
export interface InheritanceRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLInheritanceRadioGroupElement;
}
declare global {
    interface HTMLCompositionCheckboxGroupElementEventMap {
        "valueChange": string[];
    }
    interface HTMLCompositionCheckboxGroupElement extends Components.CompositionCheckboxGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCompositionCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLCompositionCheckboxGroupElement, ev: CompositionCheckboxGroupCustomEvent<HTMLCompositionCheckboxGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCompositionCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLCompositionCheckboxGroupElement, ev: CompositionCheckboxGroupCustomEvent<HTMLCompositionCheckboxGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCompositionCheckboxGroupElement: {
        prototype: HTMLCompositionCheckboxGroupElement;
        new (): HTMLCompositionCheckboxGroupElement;
    };
    interface HTMLCompositionRadioGroupElementEventMap {
        "valueChange": string;
    }
    interface HTMLCompositionRadioGroupElement extends Components.CompositionRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLCompositionRadioGroupElementEventMap>(type: K, listener: (this: HTMLCompositionRadioGroupElement, ev: CompositionRadioGroupCustomEvent<HTMLCompositionRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLCompositionRadioGroupElementEventMap>(type: K, listener: (this: HTMLCompositionRadioGroupElement, ev: CompositionRadioGroupCustomEvent<HTMLCompositionRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLCompositionRadioGroupElement: {
        prototype: HTMLCompositionRadioGroupElement;
        new (): HTMLCompositionRadioGroupElement;
    };
    /**
     * Main component that demonstrates composition-based scaling
     * with 3 components and 2 controllers (ValidationController and FocusController)
     */
    interface HTMLCompositionScalingDemoElement extends Components.CompositionScalingDemo, HTMLStencilElement {
    }
    var HTMLCompositionScalingDemoElement: {
        prototype: HTMLCompositionScalingDemoElement;
        new (): HTMLCompositionScalingDemoElement;
    };
    interface HTMLCompositionTextInputElement extends Components.CompositionTextInput, HTMLStencilElement {
    }
    var HTMLCompositionTextInputElement: {
        prototype: HTMLCompositionTextInputElement;
        new (): HTMLCompositionTextInputElement;
    };
    interface HTMLExtendedCmpElement extends Components.ExtendedCmp, HTMLStencilElement {
    }
    var HTMLExtendedCmpElement: {
        prototype: HTMLExtendedCmpElement;
        new (): HTMLExtendedCmpElement;
    };
    interface HTMLExtendedCmpCmpElement extends Components.ExtendedCmpCmp, HTMLStencilElement {
    }
    var HTMLExtendedCmpCmpElement: {
        prototype: HTMLExtendedCmpCmpElement;
        new (): HTMLExtendedCmpCmpElement;
    };
    interface HTMLExtendsAbstractElement extends Components.ExtendsAbstract, HTMLStencilElement {
    }
    var HTMLExtendsAbstractElement: {
        prototype: HTMLExtendsAbstractElement;
        new (): HTMLExtendsAbstractElement;
    };
    interface HTMLExtendsCmpCmpElement extends Components.ExtendsCmpCmp, HTMLStencilElement {
    }
    var HTMLExtendsCmpCmpElement: {
        prototype: HTMLExtendsCmpCmpElement;
        new (): HTMLExtendsCmpCmpElement;
    };
    interface HTMLExtendsControllerUpdatesElement extends Components.ExtendsControllerUpdates, HTMLStencilElement {
    }
    var HTMLExtendsControllerUpdatesElement: {
        prototype: HTMLExtendsControllerUpdatesElement;
        new (): HTMLExtendsControllerUpdatesElement;
    };
    interface HTMLExtendsDirectStateElement extends Components.ExtendsDirectState, HTMLStencilElement {
    }
    var HTMLExtendsDirectStateElement: {
        prototype: HTMLExtendsDirectStateElement;
        new (): HTMLExtendsDirectStateElement;
    };
    interface HTMLExtendsExternalElement extends Components.ExtendsExternal, HTMLStencilElement {
    }
    var HTMLExtendsExternalElement: {
        prototype: HTMLExtendsExternalElement;
        new (): HTMLExtendsExternalElement;
    };
    interface HTMLExtendsLifecycleBasicElement extends Components.ExtendsLifecycleBasic, HTMLStencilElement {
    }
    var HTMLExtendsLifecycleBasicElement: {
        prototype: HTMLExtendsLifecycleBasicElement;
        new (): HTMLExtendsLifecycleBasicElement;
    };
    interface HTMLExtendsLifecycleMultilevelElement extends Components.ExtendsLifecycleMultilevel, HTMLStencilElement {
    }
    var HTMLExtendsLifecycleMultilevelElement: {
        prototype: HTMLExtendsLifecycleMultilevelElement;
        new (): HTMLExtendsLifecycleMultilevelElement;
    };
    interface HTMLExtendsMethodsElement extends Components.ExtendsMethods, HTMLStencilElement {
    }
    var HTMLExtendsMethodsElement: {
        prototype: HTMLExtendsMethodsElement;
        new (): HTMLExtendsMethodsElement;
    };
    interface HTMLExtendsMixinCmpElement extends Components.ExtendsMixinCmp, HTMLStencilElement {
    }
    var HTMLExtendsMixinCmpElement: {
        prototype: HTMLExtendsMixinCmpElement;
        new (): HTMLExtendsMixinCmpElement;
    };
    /**
     * Test Case #3: Property & State Inheritance Basics
     * This component extends PropsStateBase to test:
     * -
     * @Prop inheritance from base class
     * -
     * @State inheritance from base class
     * - Additional
     * @Prop and
     * @State without conflicts
     * - Property reactivity (inherited props/state trigger re-renders)
     */
    interface HTMLExtendsPropsStateElement extends Components.ExtendsPropsState, HTMLStencilElement {
    }
    var HTMLExtendsPropsStateElement: {
        prototype: HTMLExtendsPropsStateElement;
        new (): HTMLExtendsPropsStateElement;
    };
    /**
     * Test Case #5: Render Method Inheritance
     * This component extends RenderBase to test:
     * - Render Inheritance: Component render() method calls super.render() to include parent template
     * - Template Composition: Component composes parent template with additional content and structure
     * - Slot Integration: Parent template slots work correctly when inherited and extended
     * - CSS Class Inheritance: CSS classes from parent template maintained in component extension
     */
    interface HTMLExtendsRenderElement extends Components.ExtendsRender, HTMLStencilElement {
    }
    var HTMLExtendsRenderElement: {
        prototype: HTMLExtendsRenderElement;
        new (): HTMLExtendsRenderElement;
    };
    interface HTMLExtendsViaHostCmpElement extends Components.ExtendsViaHostCmp, HTMLStencilElement {
    }
    var HTMLExtendsViaHostCmpElement: {
        prototype: HTMLExtendsViaHostCmpElement;
        new (): HTMLExtendsViaHostCmpElement;
    };
    interface HTMLInheritanceCheckboxGroupElementEventMap {
        "valueChange": string[];
    }
    interface HTMLInheritanceCheckboxGroupElement extends Components.InheritanceCheckboxGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInheritanceCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLInheritanceCheckboxGroupElement, ev: InheritanceCheckboxGroupCustomEvent<HTMLInheritanceCheckboxGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInheritanceCheckboxGroupElementEventMap>(type: K, listener: (this: HTMLInheritanceCheckboxGroupElement, ev: InheritanceCheckboxGroupCustomEvent<HTMLInheritanceCheckboxGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInheritanceCheckboxGroupElement: {
        prototype: HTMLInheritanceCheckboxGroupElement;
        new (): HTMLInheritanceCheckboxGroupElement;
    };
    interface HTMLInheritanceRadioGroupElementEventMap {
        "valueChange": string;
    }
    interface HTMLInheritanceRadioGroupElement extends Components.InheritanceRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLInheritanceRadioGroupElementEventMap>(type: K, listener: (this: HTMLInheritanceRadioGroupElement, ev: InheritanceRadioGroupCustomEvent<HTMLInheritanceRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLInheritanceRadioGroupElementEventMap>(type: K, listener: (this: HTMLInheritanceRadioGroupElement, ev: InheritanceRadioGroupCustomEvent<HTMLInheritanceRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLInheritanceRadioGroupElement: {
        prototype: HTMLInheritanceRadioGroupElement;
        new (): HTMLInheritanceRadioGroupElement;
    };
    /**
     * Main component that demonstrates inheritance-based scaling
     * with 3 components and 2 controllers (ValidationController and FocusController)
     */
    interface HTMLInheritanceScalingDemoElement extends Components.InheritanceScalingDemo, HTMLStencilElement {
    }
    var HTMLInheritanceScalingDemoElement: {
        prototype: HTMLInheritanceScalingDemoElement;
        new (): HTMLInheritanceScalingDemoElement;
    };
    interface HTMLInheritanceTextInputElement extends Components.InheritanceTextInput, HTMLStencilElement {
    }
    var HTMLInheritanceTextInputElement: {
        prototype: HTMLInheritanceTextInputElement;
        new (): HTMLInheritanceTextInputElement;
    };
    interface HTMLTsTargetPropsElement extends Components.TsTargetProps, HTMLStencilElement {
    }
    var HTMLTsTargetPropsElement: {
        prototype: HTMLTsTargetPropsElement;
        new (): HTMLTsTargetPropsElement;
    };
    interface HTMLElementTagNameMap {
        "composition-checkbox-group": HTMLCompositionCheckboxGroupElement;
        "composition-radio-group": HTMLCompositionRadioGroupElement;
        "composition-scaling-demo": HTMLCompositionScalingDemoElement;
        "composition-text-input": HTMLCompositionTextInputElement;
        "extended-cmp": HTMLExtendedCmpElement;
        "extended-cmp-cmp": HTMLExtendedCmpCmpElement;
        "extends-abstract": HTMLExtendsAbstractElement;
        "extends-cmp-cmp": HTMLExtendsCmpCmpElement;
        "extends-controller-updates": HTMLExtendsControllerUpdatesElement;
        "extends-direct-state": HTMLExtendsDirectStateElement;
        "extends-external": HTMLExtendsExternalElement;
        "extends-lifecycle-basic": HTMLExtendsLifecycleBasicElement;
        "extends-lifecycle-multilevel": HTMLExtendsLifecycleMultilevelElement;
        "extends-methods": HTMLExtendsMethodsElement;
        "extends-mixin-cmp": HTMLExtendsMixinCmpElement;
        "extends-props-state": HTMLExtendsPropsStateElement;
        "extends-render": HTMLExtendsRenderElement;
        "extends-via-host-cmp": HTMLExtendsViaHostCmpElement;
        "inheritance-checkbox-group": HTMLInheritanceCheckboxGroupElement;
        "inheritance-radio-group": HTMLInheritanceRadioGroupElement;
        "inheritance-scaling-demo": HTMLInheritanceScalingDemoElement;
        "inheritance-text-input": HTMLInheritanceTextInputElement;
        "ts-target-props": HTMLTsTargetPropsElement;
    }
}
declare namespace LocalJSX {
    interface CompositionCheckboxGroup {
        "onValueChange"?: (event: CompositionCheckboxGroupCustomEvent<string[]>) => void;
    }
    interface CompositionRadioGroup {
        "onValueChange"?: (event: CompositionRadioGroupCustomEvent<string>) => void;
    }
    /**
     * Main component that demonstrates composition-based scaling
     * with 3 components and 2 controllers (ValidationController and FocusController)
     */
    interface CompositionScalingDemo {
    }
    interface CompositionTextInput {
    }
    interface ExtendedCmp {
        /**
          * @default 'ExtendedCmp text'
         */
        "prop1"?: string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2"?: string;
    }
    interface ExtendedCmpCmp {
        /**
          * @default 'ExtendedCmp text'
         */
        "prop1"?: string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2"?: string;
    }
    interface ExtendsAbstract {
        /**
          * @default 'default text'
         */
        "prop1"?: string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2"?: string;
    }
    interface ExtendsCmpCmp {
        /**
          * @default 'default text'
         */
        "prop1"?: string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2"?: string;
    }
    interface ExtendsControllerUpdates {
    }
    interface ExtendsDirectState {
    }
    interface ExtendsExternal {
        /**
          * @default 'default text'
         */
        "prop1"?: string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2"?: string;
    }
    interface ExtendsLifecycleBasic {
    }
    interface ExtendsLifecycleMultilevel {
    }
    interface ExtendsMethods {
    }
    interface ExtendsMixinCmp {
        /**
          * @default 'default text'
         */
        "prop1"?: string;
        /**
          * @default 'ExtendedCmp prop2 text'
         */
        "prop2"?: string;
        /**
          * @default 'mixin b text'
         */
        "prop3"?: string;
    }
    /**
     * Test Case #3: Property & State Inheritance Basics
     * This component extends PropsStateBase to test:
     * -
     * @Prop inheritance from base class
     * -
     * @State inheritance from base class
     * - Additional
     * @Prop and
     * @State without conflicts
     * - Property reactivity (inherited props/state trigger re-renders)
     */
    interface ExtendsPropsState {
        /**
          * @default 0
         */
        "baseCount"?: number;
        /**
          * @default 'base prop value'
         */
        "baseProp"?: string;
        /**
          * @default 'component prop value'
         */
        "componentProp"?: string;
    }
    /**
     * Test Case #5: Render Method Inheritance
     * This component extends RenderBase to test:
     * - Render Inheritance: Component render() method calls super.render() to include parent template
     * - Template Composition: Component composes parent template with additional content and structure
     * - Slot Integration: Parent template slots work correctly when inherited and extended
     * - CSS Class Inheritance: CSS classes from parent template maintained in component extension
     */
    interface ExtendsRender {
    }
    interface ExtendsViaHostCmp {
    }
    interface InheritanceCheckboxGroup {
        "onValueChange"?: (event: InheritanceCheckboxGroupCustomEvent<string[]>) => void;
    }
    interface InheritanceRadioGroup {
        "onValueChange"?: (event: InheritanceRadioGroupCustomEvent<string>) => void;
    }
    /**
     * Main component that demonstrates inheritance-based scaling
     * with 3 components and 2 controllers (ValidationController and FocusController)
     */
    interface InheritanceScalingDemo {
    }
    interface InheritanceTextInput {
    }
    interface TsTargetProps {
        /**
          * @default 'basicProp'
         */
        "basicProp"?: string;
        "decoratedGetterSetterProp"?: number;
        /**
          * @default -10
         */
        "decoratedProp"?: number;
        "dynamicLifecycle"?: string[];
    }
    interface IntrinsicElements {
        "composition-checkbox-group": CompositionCheckboxGroup;
        "composition-radio-group": CompositionRadioGroup;
        "composition-scaling-demo": CompositionScalingDemo;
        "composition-text-input": CompositionTextInput;
        "extended-cmp": ExtendedCmp;
        "extended-cmp-cmp": ExtendedCmpCmp;
        "extends-abstract": ExtendsAbstract;
        "extends-cmp-cmp": ExtendsCmpCmp;
        "extends-controller-updates": ExtendsControllerUpdates;
        "extends-direct-state": ExtendsDirectState;
        "extends-external": ExtendsExternal;
        "extends-lifecycle-basic": ExtendsLifecycleBasic;
        "extends-lifecycle-multilevel": ExtendsLifecycleMultilevel;
        "extends-methods": ExtendsMethods;
        "extends-mixin-cmp": ExtendsMixinCmp;
        "extends-props-state": ExtendsPropsState;
        "extends-render": ExtendsRender;
        "extends-via-host-cmp": ExtendsViaHostCmp;
        "inheritance-checkbox-group": InheritanceCheckboxGroup;
        "inheritance-radio-group": InheritanceRadioGroup;
        "inheritance-scaling-demo": InheritanceScalingDemo;
        "inheritance-text-input": InheritanceTextInput;
        "ts-target-props": TsTargetProps;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "composition-checkbox-group": LocalJSX.CompositionCheckboxGroup & JSXBase.HTMLAttributes<HTMLCompositionCheckboxGroupElement>;
            "composition-radio-group": LocalJSX.CompositionRadioGroup & JSXBase.HTMLAttributes<HTMLCompositionRadioGroupElement>;
            /**
             * Main component that demonstrates composition-based scaling
             * with 3 components and 2 controllers (ValidationController and FocusController)
             */
            "composition-scaling-demo": LocalJSX.CompositionScalingDemo & JSXBase.HTMLAttributes<HTMLCompositionScalingDemoElement>;
            "composition-text-input": LocalJSX.CompositionTextInput & JSXBase.HTMLAttributes<HTMLCompositionTextInputElement>;
            "extended-cmp": LocalJSX.ExtendedCmp & JSXBase.HTMLAttributes<HTMLExtendedCmpElement>;
            "extended-cmp-cmp": LocalJSX.ExtendedCmpCmp & JSXBase.HTMLAttributes<HTMLExtendedCmpCmpElement>;
            "extends-abstract": LocalJSX.ExtendsAbstract & JSXBase.HTMLAttributes<HTMLExtendsAbstractElement>;
            "extends-cmp-cmp": LocalJSX.ExtendsCmpCmp & JSXBase.HTMLAttributes<HTMLExtendsCmpCmpElement>;
            "extends-controller-updates": LocalJSX.ExtendsControllerUpdates & JSXBase.HTMLAttributes<HTMLExtendsControllerUpdatesElement>;
            "extends-direct-state": LocalJSX.ExtendsDirectState & JSXBase.HTMLAttributes<HTMLExtendsDirectStateElement>;
            "extends-external": LocalJSX.ExtendsExternal & JSXBase.HTMLAttributes<HTMLExtendsExternalElement>;
            "extends-lifecycle-basic": LocalJSX.ExtendsLifecycleBasic & JSXBase.HTMLAttributes<HTMLExtendsLifecycleBasicElement>;
            "extends-lifecycle-multilevel": LocalJSX.ExtendsLifecycleMultilevel & JSXBase.HTMLAttributes<HTMLExtendsLifecycleMultilevelElement>;
            "extends-methods": LocalJSX.ExtendsMethods & JSXBase.HTMLAttributes<HTMLExtendsMethodsElement>;
            "extends-mixin-cmp": LocalJSX.ExtendsMixinCmp & JSXBase.HTMLAttributes<HTMLExtendsMixinCmpElement>;
            /**
             * Test Case #3: Property & State Inheritance Basics
             * This component extends PropsStateBase to test:
             * -
             * @Prop inheritance from base class
             * -
             * @State inheritance from base class
             * - Additional
             * @Prop and
             * @State without conflicts
             * - Property reactivity (inherited props/state trigger re-renders)
             */
            "extends-props-state": LocalJSX.ExtendsPropsState & JSXBase.HTMLAttributes<HTMLExtendsPropsStateElement>;
            /**
             * Test Case #5: Render Method Inheritance
             * This component extends RenderBase to test:
             * - Render Inheritance: Component render() method calls super.render() to include parent template
             * - Template Composition: Component composes parent template with additional content and structure
             * - Slot Integration: Parent template slots work correctly when inherited and extended
             * - CSS Class Inheritance: CSS classes from parent template maintained in component extension
             */
            "extends-render": LocalJSX.ExtendsRender & JSXBase.HTMLAttributes<HTMLExtendsRenderElement>;
            "extends-via-host-cmp": LocalJSX.ExtendsViaHostCmp & JSXBase.HTMLAttributes<HTMLExtendsViaHostCmpElement>;
            "inheritance-checkbox-group": LocalJSX.InheritanceCheckboxGroup & JSXBase.HTMLAttributes<HTMLInheritanceCheckboxGroupElement>;
            "inheritance-radio-group": LocalJSX.InheritanceRadioGroup & JSXBase.HTMLAttributes<HTMLInheritanceRadioGroupElement>;
            /**
             * Main component that demonstrates inheritance-based scaling
             * with 3 components and 2 controllers (ValidationController and FocusController)
             */
            "inheritance-scaling-demo": LocalJSX.InheritanceScalingDemo & JSXBase.HTMLAttributes<HTMLInheritanceScalingDemoElement>;
            "inheritance-text-input": LocalJSX.InheritanceTextInput & JSXBase.HTMLAttributes<HTMLInheritanceTextInputElement>;
            "ts-target-props": LocalJSX.TsTargetProps & JSXBase.HTMLAttributes<HTMLTsTargetPropsElement>;
        }
    }
}
