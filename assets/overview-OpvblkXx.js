import{j as e}from"./jsx-runtime-D_zvdyIk.js";import{useMDXComponents as s}from"./index-Cz8RAiW5.js";import{M as r}from"./blocks-CteF97tp.js";import"./iframe-C9EEsFzF.js";import"./preload-helper-D9Z9MdNV.js";import"./index-CzFh4XEe.js";function i(n){const t={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...s(),...n.components};return e.jsxs(e.Fragment,{children:[e.jsx(r,{title:"Testing/Overview"}),`
`,e.jsx(t.h1,{id:"stenciljs-testing-strategy",children:"Stencil.js Testing Strategy"}),`
`,e.jsx(t.p,{children:"This document outlines the testing strategy for the Stencil.js codebase. It is centered around a GenAI-powered loop to ensure a comprehensive and robust testing suite that is both maintainable and scalable."}),`
`,e.jsx(t.h2,{id:"philosophy",children:"Philosophy"}),`
`,e.jsx(t.p,{children:"For a foundational library like Stencil, the testing strategy must be rigorous. It should not only validate that features work as expected but also ensure they are reliable in isolation and play well with others. We follow a model inspired by the classic testing pyramid."}),`
`,e.jsxs(t.p,{children:["A key aspect of our strategy is recognizing the difference between ",e.jsx(t.strong,{children:"static coverage analysis"})," and ",e.jsx(t.strong,{children:"runtime behavior testing"}),". Our coverage scripts work by statically analyzing the source code for specific patterns (e.g., the presence of a ",e.jsx(t.code,{children:"@Prop"})," decorator with certain options). This is a fast and effective way to inventory our features, but it does not execute the code to verify its behavior. Therefore, our testing strategy is designed to satisfy both our static analysis tools and the need for robust, behavior-driven validation."]}),`
`,e.jsxs(t.blockquote,{children:[`
`,e.jsxs(t.p,{children:[e.jsx(t.strong,{children:"Note:"})," For a deeper dive into how the permutation matrix is generated and used for coverage, see ",e.jsx(t.a,{href:"?path=/docs/testing-decorators-matrix-generation--docs",children:"Matrix Generation"}),"."]}),`
`]}),`
`,e.jsx(t.h2,{id:"summary-the-testing-pyramid-in-practice",children:"Summary: The Testing Pyramid in Practice"}),`
`,e.jsxs("table",{children:[e.jsx("thead",{children:e.jsxs("tr",{children:[e.jsx("th",{children:"Test Type"}),e.jsx("th",{children:"Directory"}),e.jsx("th",{children:"Technology"}),e.jsx("th",{children:"Goal"}),e.jsx("th",{children:"Details"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{children:[e.jsx("td",{children:e.jsx("strong",{children:"Core Tests"})}),e.jsx("td",{children:e.jsx("code",{children:"src/"})}),e.jsx("td",{children:"Jest"}),e.jsx("td",{children:"Verify Stencil's internal logic and compiler functionality."}),e.jsx("td",{children:e.jsx(t.a,{href:"?path=/docs/testing-tests-core--docs",children:"Core Testing Docs"})})]}),e.jsxs("tr",{children:[e.jsx("td",{children:e.jsx("strong",{children:"Component Tests"})}),e.jsx("td",{children:e.jsx("code",{children:"test/wdio/"})}),e.jsxs("td",{children:["WebdriverIO (",e.jsx("code",{children:"@wdio/browser-runner/stencil"}),")"]}),e.jsx("td",{children:"Verify individual features in isolation and satisfy static analysis."}),e.jsx("td",{children:e.jsx(t.a,{href:"?path=/docs/testing-tests-component--docs",children:"Component Testing Docs"})})]}),e.jsxs("tr",{children:[e.jsx("td",{children:e.jsx("strong",{children:"E2E Tests"})}),e.jsx("td",{children:e.jsx("code",{children:"test/end-to-end/"})}),e.jsxs("td",{children:["Stencil's ",e.jsx("code",{children:"newE2EPage()"})," (Puppeteer)"]}),e.jsx("td",{children:"Verify that features work correctly together (e.g. multiple decorators, render function) and that component behavior is correct in a browser environment."}),e.jsx("td",{children:e.jsx(t.a,{href:"?path=/docs/testing-tests-e2e--docs",children:"E2E Testing Docs"})})]})]})]}),`
`,e.jsx(t.h2,{id:"the-genai-powered-testing-loop",children:"The GenAI-Powered Testing Loop"}),`
`,e.jsx(t.p,{children:"A groundbreaking aspect of our testing strategy is its reliance on a GenAI-powered iterative loop. This approach allows us to systematically work towards 100% coverage of all feature permutations in a way that is both dynamic and self-improving. The loop is as follows:"}),`
`,e.jsxs(t.ol,{children:[`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Define Component Permutations"}),": For a given feature, like a decorator, we first study all its possible variations and options. These are documented in a human- and machine-readable permutation matrix within an ",e.jsx(t.code,{children:".mdx"})," file. This matrix serves as the single source of truth for which component permutations need to be tested. For details on how the matrix is generated, see ",e.jsx(t.a,{href:"?path=/docs/testing-decorators-matrix-generation--docs",children:"Matrix Generation"}),"."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"AI-Driven Component Test Generation"}),": A generative AI assistant uses the permutation matrix as a blueprint to generate the necessary component-level tests in the ",e.jsx(t.code,{children:"test/wdio"})," directory. For each permutation, it creates an isolated component and a corresponding test to exercise its behavior."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Test Execution and Validation"}),": Before checking coverage, the newly generated ",e.jsx(t.code,{children:"wdio"})," tests are run to ensure they pass. This step is critical to confirm that the generated components and tests are functionally correct and adhere to the established patterns."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Coverage Analysis & Matrix Update"}),": After the tests are generated and pass, a custom coverage script analyzes the codebase. It updates the permutation matrix ",e.jsx(t.code,{children:".mdx"})," file with the latest coverage statistics, clearly marking which component permutations are implemented and tested, and which are missing."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Iterate and Refine"}),": The AI reviews the updated matrix. If any permutations are uncovered, it generates the missing components and tests to cover the gaps. This loop continues until all permutations in the matrix are covered, ensuring our test suite is as comprehensive as possible."]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Document Learnings"}),": Once 100% coverage is achieved, the AI documents any learnings from the testing iteration in the appropriate ",e.jsx(t.code,{children:".ai"})," folder files. This includes mistakes made during test generation, loopholes discovered in coverage scripts, improvements to documentation, and any patterns or best practices identified. This step ensures that each iteration builds upon the knowledge gained from previous cycles, making the process continuously more efficient and accurate."]}),`
`]}),`
`,e.jsx(t.p,{children:"This iterative process allows us to not only achieve but also maintain high test coverage over time, adapting as new features and variations are introduced while continuously improving our methodology."}),`
`,e.jsx(t.h2,{id:"an-open-community-driven-framework",children:"An Open, Community-Driven Framework"}),`
`,e.jsx(t.p,{children:"While the concept of a GenAI-powered testing loop is powerful, its true potential is unlocked through community collaboration. We envision this testing strategy as a public project, open to contributions from everyone."}),`
`,e.jsx(t.p,{children:"The framework is designed to be model-agnostic. Anyone, whether they have access to cutting-edge proprietary AI or open-source models, can participate. The process is simple:"}),`
`,e.jsxs(t.ol,{children:[`
`,e.jsx(t.li,{children:"Fork the repository."}),`
`,e.jsx(t.li,{children:"Run the testing loop using your preferred AI model."}),`
`,e.jsx(t.li,{children:"If your model generates new, more efficient, or more comprehensive tests, submit a pull request."}),`
`]}),`
`,e.jsx(t.p,{children:"This approach allows us to harness the collective intelligence and diverse capabilities of the entire community. By crowdsourcing the test generation process, we can build a more robust, resilient, and thoroughly-vetted testing suite than any single team or model could create alone."}),`
`,e.jsx(t.h2,{id:"continuous-improvement",children:"Continuous Improvement"}),`
`,e.jsx(t.p,{children:"This testing strategy is a living document. We will continue to refine our approach, adopt new tools, and improve our processes over time to ensure Stencil remains a reliable and high-quality framework for all developers."}),`
`,e.jsxs(t.p,{children:["A core tenet of this continuous improvement is the practice of documenting our learnings. After each major testing iteration, we will update the relevant documentationâ€”including this strategy, the component-level and end-to-end testing guides, and the ",e.jsx(t.a,{href:"?path=/docs/testing-audit--docs",children:"audit log"}),"â€”with any new insights, patterns, or challenges we encountered. This ensures that our institutional knowledge grows with our test suite."]}),`
`,e.jsx(t.p,{children:e.jsx(t.strong,{children:"Key areas for learning documentation include:"})}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"AI Mistakes and Corrections"}),": Recording instances where the AI generated incorrect or suboptimal tests, along with the corrections made"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Coverage Script Gaps"}),": Documenting loopholes or blind spots discovered in coverage scripts and how they were addressed"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Documentation Improvements"}),": Noting areas where guides or instructions were unclear or incomplete"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Process Optimizations"}),": Capturing workflow improvements or shortcuts discovered during iterations"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.strong,{children:"Pattern Recognition"}),": Identifying recurring themes or best practices that emerge from the testing process"]}),`
`]}),`
`,e.jsx(t.p,{children:"As this is our first time implementing the GenAI-powered loop, we anticipate a learning period where mistakes are possible. Our commitment is to learn from these experiences and rapidly evolve towards a rock-solid automated testing framework."}),`
`,e.jsx(t.p,{children:"By adhering to this strategy, we build a comprehensive test suite that is both robust and maintainable, ensuring that Stencil remains a reliable tool for developers."}),`
`,e.jsx(t.hr,{}),`
`,e.jsx("div",{style:{marginTop:"3rem",textAlign:"center"},children:e.jsxs("span",{style:{fontSize:36,fontWeight:800,color:"#3b82f6",background:"#fff",borderRadius:20,padding:"3rem 4rem",display:"inline-block",boxShadow:"0 8px 32px rgba(59,130,246,0.10)",letterSpacing:"0.03em",border:"3px solid #0ea5e9",marginBottom:"2.5rem",textShadow:"none",position:"relative",overflow:"hidden"},children:[e.jsx("span",{style:{display:"block",fontSize:28,color:"#0ea5e9",fontWeight:900,marginBottom:18,zIndex:1,position:"relative",letterSpacing:"0.04em"},children:e.jsxs(t.p,{children:["ðŸš€ ",e.jsx(t.a,{href:"?path=/docs/testing-roadmap-2025--docs",children:"2025 Testing Roadmap: Dive into the future of Stencil.js testing!"})," ðŸš€"]})}),e.jsx("span",{style:{display:"block",fontSize:20,color:"#6366f1",fontWeight:500,marginTop:18,zIndex:1,position:"relative",letterSpacing:"0.02em"},children:e.jsx(t.p,{children:"Next-gen coverage, GenAI-powered automation, and SSR mastery await."})})]})})]})}function p(n={}){const{wrapper:t}={...s(),...n.components};return t?e.jsx(t,{...n,children:e.jsx(i,{...n})}):i(n)}export{p as default};
